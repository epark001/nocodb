var FindClause = /** @class */ (function () {
    function FindClause() {
    }
    FindClause.make = function (option) {
        var _a, _b, _c, _d;
        return {
            limit: (_a = option.limit) !== null && _a !== void 0 ? _a : 10,
            sort: (_b = option.sort) !== null && _b !== void 0 ? _b : '',
            offset: (_c = option.offset) !== null && _c !== void 0 ? _c : 0,
            xwhere: (_d = option.where) !== null && _d !== void 0 ? _d : ''
        };
    };
    return FindClause;
}());

// Gets all non-builtin properties up the prototype chain
const getAllProperties = object => {
	const properties = new Set();

	do {
		for (const key of Reflect.ownKeys(object)) {
			properties.add([object, key]);
		}
	} while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);

	return properties;
};

var autoBind = (self, {include, exclude} = {}) => {
	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);

		if (include) {
			return include.some(match);
		}

		if (exclude) {
			return !exclude.some(match);
		}

		return true;
	};

	for (const [object, key] of getAllProperties(self.constructor.prototype)) {
		if (key === 'constructor' || !filter(key)) {
			continue;
		}

		const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
		if (descriptor && typeof descriptor.value === 'function') {
			self[key] = self[key].bind(self);
		}
	}

	return self;
};

var BaseComponent = /** @class */ (function () {
    function BaseComponent(app) {
        this.app = app;
        autoBind(this);
    }
    return BaseComponent;
}());

/**
 * BaseClass for Router files in REST APIs
 *
 * @class
 * @classdesc BaseClass for Router files in REST APIs
 */
var BaseService = /** @class */ (function () {
    function BaseService() {
        autoBind(this);
    }
    return BaseService;
}());

/* tslint:disable:typedef */
// import {Handler, any} from 'express';
/**
 * BaseClass for Router files in REST APIs
 *
 * @class
 * @classdesc BaseClass for Router files in REST APIs
 */
var BaseRouter = /** @class */ (function () {
    function BaseRouter() {
        autoBind(this);
    }
    BaseRouter.errJson = function (res, code, message) {
        if (code === void 0) { code = 200; }
        return res.status(code).json({ message: message });
    };
    /**
     * @param {Object} app - app context
     */
    // constructor(app: any) {
    //   this.app = app;
    // }
    BaseRouter.prototype.mapRoutes = function () {
        throw new Error(this.constructor.name + ".mapRoutes is not implemented");
    };
    BaseRouter.prototype.catchErr = function (handler) {
        var _this = this;
        return function (req, res, next) {
            Promise.resolve(handler.call(_this, req, res, next)).catch(function (err) {
                res.status(500).json({ msg: err.message });
                // next(err);
            });
        };
    };
    BaseRouter.prototype.errOk = function (res, dto) {
        if (dto !== null || dto !== undefined) {
            res.type('application/json');
            return res.status(200).json(dto);
        }
        else {
            return res.sendStatus(200);
        }
    };
    BaseRouter.prototype.created = function (res) {
        return res.sendStatus(201);
    };
    BaseRouter.prototype.errBadRequest = function (res, message) {
        return BaseRouter.errJson(res, 400, message ? message : 'Bad Request');
    };
    BaseRouter.prototype.errUnauthorized = function (res, message) {
        return BaseRouter.errJson(res, 401, message ? message : 'Unauthorized');
    };
    BaseRouter.prototype.errPaymentRequired = function (res, message) {
        return BaseRouter.errJson(res, 402, message ? message : 'Payment required');
    };
    BaseRouter.prototype.errForbidden = function (res, message) {
        return BaseRouter.errJson(res, 403, message ? message : 'Forbidden');
    };
    BaseRouter.prototype.errNotFound = function (res, message) {
        return BaseRouter.errJson(res, 404, message ? message : 'Not found');
    };
    BaseRouter.prototype.errConflict = function (res, message) {
        return BaseRouter.errJson(res, 409, message ? message : 'Conflict');
    };
    BaseRouter.prototype.errTooMany = function (res, message) {
        return BaseRouter.errJson(res, 429, message ? message : 'Too many requests');
    };
    BaseRouter.prototype.errNotImplemented = function (res, message) {
        return BaseRouter.errJson(res, 501, message ? message : 'Not Implemented');
    };
    BaseRouter.prototype.todo = function (res) {
        return BaseRouter.errJson(res, 400, 'TODO');
    };
    BaseRouter.prototype.errFailed = function (res, error) {
        return res.status(500).json({
            message: error.toString()
        });
    };
    return BaseRouter;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/* tslint:disable:typedef */
/**
 * BaseClass for Router files in REST APIs
 *
 * @class
 * @classdesc BaseClass for Router files in REST APIs
 */
var BaseResolver = /** @class */ (function () {
    //
    // public static errJson(
    //   res: Response, code: number = 200, message: string
    // ): any {
    //   return res.status(code).json({message})
    // }
    function BaseResolver() {
        autoBind(this);
    }
    /**
     * @param {Object} app - app context
     */
    // constructor(app: any) {
    //   this.app = app;
    // }
    BaseResolver.prototype.resolvers = function () {
        throw new Error(this.constructor.name + ".mapRoutes is not implemented");
    };
    BaseResolver.prototype.applyMiddlewares = function (handlers, resolvers, postHandlers) {
        var _this = this;
        if (handlers === void 0) { handlers = []; }
        if (resolvers === void 0) { resolvers = {}; }
        if (postHandlers === void 0) { postHandlers = []; }
        if (!handlers) {
            return resolvers;
        }
        var _loop_1 = function (name, resolver) {
            resolvers[name] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return __awaiter(_this, void 0, void 0, function () {
                    var _a, handlers_1, handler, result, _b, postHandlers_1, handler, e_1;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                _c.trys.push([0, 10, , 11]);
                                _a = 0, handlers_1 = handlers;
                                _c.label = 1;
                            case 1:
                                if (!(_a < handlers_1.length)) return [3 /*break*/, 4];
                                handler = handlers_1[_a];
                                return [4 /*yield*/, handler.apply(void 0, args)];
                            case 2:
                                _c.sent();
                                _c.label = 3;
                            case 3:
                                _a++;
                                return [3 /*break*/, 1];
                            case 4: return [4 /*yield*/, resolver.apply(void 0, args)];
                            case 5:
                                result = _c.sent();
                                if (!postHandlers) return [3 /*break*/, 9];
                                _b = 0, postHandlers_1 = postHandlers;
                                _c.label = 6;
                            case 6:
                                if (!(_b < postHandlers_1.length)) return [3 /*break*/, 9];
                                handler = postHandlers_1[_b];
                                return [4 /*yield*/, handler.apply(void 0, __spreadArrays([result], args))];
                            case 7:
                                _c.sent();
                                _c.label = 8;
                            case 8:
                                _b++;
                                return [3 /*break*/, 6];
                            case 9: return [2 /*return*/, result];
                            case 10:
                                e_1 = _c.sent();
                                throw e_1;
                            case 11: return [2 /*return*/];
                        }
                    });
                });
            };
        };
        for (var _i = 0, _a = Object.entries(resolvers); _i < _a.length; _i++) {
            var _b = _a[_i], name = _b[0], resolver = _b[1];
            _loop_1(name, resolver);
        }
        return resolvers;
    };
    return BaseResolver;
}());

var BaseType = /** @class */ (function () {
    function BaseType() {
        autoBind(this);
    }
    BaseType.applyMiddlewareForLoader = function (handlers, loader, postHandlers) {
        var _this = this;
        if (handlers === void 0) { handlers = []; }
        if (postHandlers === void 0) { postHandlers = []; }
        if (!handlers) {
            return loader;
        }
        return function (args) { return __awaiter(_this, void 0, void 0, function () {
            var _i, handlers_1, handler, result, _a, postHandlers_1, handler, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 10, , 11]);
                        _i = 0, handlers_1 = handlers;
                        _b.label = 1;
                    case 1:
                        if (!(_i < handlers_1.length)) return [3 /*break*/, 4];
                        handler = handlers_1[_i];
                        return [4 /*yield*/, handler(args[0][1], args[0][2], args[0][3], args.map(function (_a) {
                                var id = _a[0];
                                return id;
                            }))];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [4 /*yield*/, loader(args.map(function (_a) {
                            var id = _a[0];
                            return id;
                        }))];
                    case 5:
                        result = _b.sent();
                        if (!postHandlers) return [3 /*break*/, 9];
                        _a = 0, postHandlers_1 = postHandlers;
                        _b.label = 6;
                    case 6:
                        if (!(_a < postHandlers_1.length)) return [3 /*break*/, 9];
                        handler = postHandlers_1[_a];
                        return [4 /*yield*/, handler.apply(void 0, __spreadArrays([result], args[0]))];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8:
                        _a++;
                        return [3 /*break*/, 6];
                    case 9: return [2 /*return*/, result];
                    case 10:
                        e_1 = _b.sent();
                        throw e_1;
                    case 11: return [2 /*return*/];
                }
            });
        }); };
    };
    BaseType.prototype.applyMiddlewares = function (handlers, loaders, postHandlers) {
        var _this = this;
        if (handlers === void 0) { handlers = []; }
        if (loaders === void 0) { loaders = {}; }
        if (postHandlers === void 0) { postHandlers = []; }
        // return if there is no middlewares
        if (!handlers) {
            return loaders;
        }
        var _loop_1 = function (name, loader) {
            // wrap the loader function
            loaders[name] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return __awaiter(_this, void 0, void 0, function () {
                    var _a, handlers_2, handler, result, _b, postHandlers_2, handler, e_2;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                _c.trys.push([0, 10, , 11]);
                                _a = 0, handlers_2 = handlers;
                                _c.label = 1;
                            case 1:
                                if (!(_a < handlers_2.length)) return [3 /*break*/, 4];
                                handler = handlers_2[_a];
                                return [4 /*yield*/, handler.apply(void 0, args)];
                            case 2:
                                _c.sent();
                                _c.label = 3;
                            case 3:
                                _a++;
                                return [3 /*break*/, 1];
                            case 4: return [4 /*yield*/, loader(args[0])
                                // post handlers
                            ];
                            case 5:
                                result = _c.sent();
                                if (!postHandlers) return [3 /*break*/, 9];
                                _b = 0, postHandlers_2 = postHandlers;
                                _c.label = 6;
                            case 6:
                                if (!(_b < postHandlers_2.length)) return [3 /*break*/, 9];
                                handler = postHandlers_2[_b];
                                return [4 /*yield*/, handler.apply(void 0, __spreadArrays([result], args))];
                            case 7:
                                _c.sent();
                                _c.label = 8;
                            case 8:
                                _b++;
                                return [3 /*break*/, 6];
                            case 9: 
                            // return the result
                            return [2 /*return*/, result];
                            case 10:
                                e_2 = _c.sent();
                                throw e_2;
                            case 11: return [2 /*return*/];
                        }
                    });
                });
            };
        };
        // iterate over loaders
        for (var _i = 0, _a = Object.entries(loaders); _i < _a.length; _i++) {
            var _b = _a[_i], name = _b[0], loader = _b[1];
            _loop_1(name, loader);
        }
        return loaders;
    };
    return BaseType;
}());

// import {Handler} from "express";
var RouteType;
(function (RouteType) {
    RouteType["GET"] = "get";
    RouteType["POST"] = "post";
    RouteType["PUT"] = "put";
    RouteType["PATCH"] = "patch";
    RouteType["DELETE"] = "delete";
    RouteType["HEAD"] = "head";
    RouteType["OPTIONS"] = "options";
})(RouteType || (RouteType = {}));

/**
 * Copyright (c) 2019-present, GraphQL Foundation
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// A Function, which when given an Array of keys, returns a Promise of an Array
// of values or Errors.
// Optionally turn off batching or caching or provide a cache key function or a
// custom cache instance.
// If a custom cache is provided, it must be of this type (a subset of ES6 Map).

/**
 * A `DataLoader` creates a public API for loading data from a particular
 * data back-end with unique keys such as the `id` column of a SQL table or
 * document name in a MongoDB database, given a batch loading function.
 *
 * Each `DataLoader` instance contains a unique memoized cache. Use caution when
 * used in long-lived applications or those which serve many users with
 * different access permissions and consider creating a new instance per
 * web request.
 */
var DataLoader =
/*#__PURE__*/
function () {
  function DataLoader(batchLoadFn, options) {
    if (typeof batchLoadFn !== 'function') {
      throw new TypeError('DataLoader must be constructed with a function which accepts ' + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
    }

    this._batchLoadFn = batchLoadFn;
    this._maxBatchSize = getValidMaxBatchSize(options);
    this._batchScheduleFn = getValidBatchScheduleFn(options);
    this._cacheKeyFn = getValidCacheKeyFn(options);
    this._cacheMap = getValidCacheMap(options);
    this._batch = null;
  } // Private


  var _proto = DataLoader.prototype;

  /**
   * Loads a key, returning a `Promise` for the value represented by that key.
   */
  _proto.load = function load(key) {
    if (key === null || key === undefined) {
      throw new TypeError('The loader.load() function must be called with a value,' + ("but got: " + String(key) + "."));
    }

    var batch = getCurrentBatch(this);
    var cacheMap = this._cacheMap;

    var cacheKey = this._cacheKeyFn(key); // If caching and there is a cache-hit, return cached Promise.


    if (cacheMap) {
      var cachedPromise = cacheMap.get(cacheKey);

      if (cachedPromise) {
        var cacheHits = batch.cacheHits || (batch.cacheHits = []);
        return new Promise(function (resolve) {
          cacheHits.push(function () {
            return resolve(cachedPromise);
          });
        });
      }
    } // Otherwise, produce a new Promise for this key, and enqueue it to be
    // dispatched along with the current batch.


    batch.keys.push(key);
    var promise = new Promise(function (resolve, reject) {
      batch.callbacks.push({
        resolve: resolve,
        reject: reject
      });
    }); // If caching, cache this promise.

    if (cacheMap) {
      cacheMap.set(cacheKey, promise);
    }

    return promise;
  }
  /**
   * Loads multiple keys, promising an array of values:
   *
   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);
   *
   * This is similar to the more verbose:
   *
   *     var [ a, b ] = await Promise.all([
   *       myLoader.load('a'),
   *       myLoader.load('b')
   *     ]);
   *
   * However it is different in the case where any load fails. Where
   * Promise.all() would reject, loadMany() always resolves, however each result
   * is either a value or an Error instance.
   *
   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);
   *     // c instanceof Error
   *
   */
  ;

  _proto.loadMany = function loadMany(keys) {
    if (!isArrayLike(keys)) {
      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + ("but got: " + keys + "."));
    } // Support ArrayLike by using only minimal property access


    var loadPromises = [];

    for (var i = 0; i < keys.length; i++) {
      loadPromises.push(this.load(keys[i])["catch"](function (error) {
        return error;
      }));
    }

    return Promise.all(loadPromises);
  }
  /**
   * Clears the value at `key` from the cache, if it exists. Returns itself for
   * method chaining.
   */
  ;

  _proto.clear = function clear(key) {
    var cacheMap = this._cacheMap;

    if (cacheMap) {
      var cacheKey = this._cacheKeyFn(key);

      cacheMap["delete"](cacheKey);
    }

    return this;
  }
  /**
   * Clears the entire cache. To be used when some event results in unknown
   * invalidations across this particular `DataLoader`. Returns itself for
   * method chaining.
   */
  ;

  _proto.clearAll = function clearAll() {
    var cacheMap = this._cacheMap;

    if (cacheMap) {
      cacheMap.clear();
    }

    return this;
  }
  /**
   * Adds the provided key and value to the cache. If the key already
   * exists, no change is made. Returns itself for method chaining.
   *
   * To prime the cache with an error at a key, provide an Error instance.
   */
  ;

  _proto.prime = function prime(key, value) {
    var cacheMap = this._cacheMap;

    if (cacheMap) {
      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.


      if (cacheMap.get(cacheKey) === undefined) {
        // Cache a rejected promise if the value is an Error, in order to match
        // the behavior of load(key).
        var promise;

        if (value instanceof Error) {
          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed
          // for a given key, we want to disable unhandled promise rejection.

          promise["catch"](function () {});
        } else {
          promise = Promise.resolve(value);
        }

        cacheMap.set(cacheKey, promise);
      }
    }

    return this;
  };

  return DataLoader;
}(); // Private: Enqueue a Job to be executed after all "PromiseJobs" Jobs.
//
// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur
// after the current execution context has completed:
// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues
//
// Node.js uses the `process.nextTick` mechanism to implement the concept of a
// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after
// the current call stack ends.
//
// When calling `then` on a Promise, it enqueues a Job on a specific
// "PromiseJobs" JobQueue which is flushed in Node as a single Job on the
// global JobQueue.
//
// DataLoader batches all loads which occur in a single frame of execution, but
// should include in the batch all loads which occur during the flushing of the
// "PromiseJobs" JobQueue after that same execution frame.
//
// In order to avoid the DataLoader dispatch Job occuring before "PromiseJobs",
// A Promise Job is created with the sole purpose of enqueuing a global Job,
// ensuring that it always occurs after "PromiseJobs" ends.
//
// Node.js's job queue is unique. Browsers do not have an equivalent mechanism
// for enqueuing a job to be performed after promise microtasks and before the
// next macrotask. For browser environments, a macrotask is used (via
// setImmediate or setTimeout) at a potential performance penalty.


var enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {
  if (!resolvedPromise) {
    resolvedPromise = Promise.resolve();
  }

  resolvedPromise.then(function () {
    return process.nextTick(fn);
  });
} : setImmediate || setTimeout; // Private: cached resolved Promise instance

var resolvedPromise; // Private: Describes a batch of requests

// Private: Either returns the current batch, or creates and schedules a
// dispatch of a new batch for the given loader.
function getCurrentBatch(loader) {
  // If there is an existing batch which has not yet dispatched and is within
  // the limit of the batch size, then return it.
  var existingBatch = loader._batch;

  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {
    return existingBatch;
  } // Otherwise, create a new batch for this loader.


  var newBatch = {
    hasDispatched: false,
    keys: [],
    callbacks: []
  }; // Store it on the loader so it may be reused.

  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.

  loader._batchScheduleFn(function () {
    return dispatchBatch(loader, newBatch);
  });

  return newBatch;
}

function dispatchBatch(loader, batch) {
  // Mark this batch as having been dispatched.
  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.

  if (batch.keys.length === 0) {
    resolveCacheHits(batch);
    return;
  } // Call the provided batchLoadFn for this loader with the batch's keys and
  // with the loader as the `this` context.


  var batchPromise = loader._batchLoadFn(batch.keys); // Assert the expected response from batchLoadFn


  if (!batchPromise || typeof batchPromise.then !== 'function') {
    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + ("not return a Promise: " + String(batchPromise) + ".")));
  } // Await the resolution of the call to batchLoadFn.


  batchPromise.then(function (values) {
    // Assert the expected resolution from batchLoadFn.
    if (!isArrayLike(values)) {
      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + ("not return a Promise of an Array: " + String(values) + "."));
    }

    if (values.length !== batch.keys.length) {
      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
    } // Resolve all cache hits in the same micro-task as freshly loaded values.


    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.

    for (var i = 0; i < batch.callbacks.length; i++) {
      var value = values[i];

      if (value instanceof Error) {
        batch.callbacks[i].reject(value);
      } else {
        batch.callbacks[i].resolve(value);
      }
    }
  })["catch"](function (error) {
    return failedDispatch(loader, batch, error);
  });
} // Private: do not cache individual loads if the entire batch dispatch fails,
// but still reject each request so they do not hang.


function failedDispatch(loader, batch, error) {
  // Cache hits are resolved, even though the batch failed.
  resolveCacheHits(batch);

  for (var i = 0; i < batch.keys.length; i++) {
    loader.clear(batch.keys[i]);
    batch.callbacks[i].reject(error);
  }
} // Private: Resolves the Promises for any cache hits in this batch.


function resolveCacheHits(batch) {
  if (batch.cacheHits) {
    for (var i = 0; i < batch.cacheHits.length; i++) {
      batch.cacheHits[i]();
    }
  }
} // Private: given the DataLoader's options, produce a valid max batch size.


function getValidMaxBatchSize(options) {
  var shouldBatch = !options || options.batch !== false;

  if (!shouldBatch) {
    return 1;
  }

  var maxBatchSize = options && options.maxBatchSize;

  if (maxBatchSize === undefined) {
    return Infinity;
  }

  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {
    throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
  }

  return maxBatchSize;
} // Private


function getValidBatchScheduleFn(options) {
  var batchScheduleFn = options && options.batchScheduleFn;

  if (batchScheduleFn === undefined) {
    return enqueuePostPromiseJob;
  }

  if (typeof batchScheduleFn !== 'function') {
    throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
  }

  return batchScheduleFn;
} // Private: given the DataLoader's options, produce a cache key function.


function getValidCacheKeyFn(options) {
  var cacheKeyFn = options && options.cacheKeyFn;

  if (cacheKeyFn === undefined) {
    return function (key) {
      return key;
    };
  }

  if (typeof cacheKeyFn !== 'function') {
    throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
  }

  return cacheKeyFn;
} // Private: given the DataLoader's options, produce a CacheMap to be used.


function getValidCacheMap(options) {
  var shouldCache = !options || options.cache !== false;

  if (!shouldCache) {
    return null;
  }

  var cacheMap = options && options.cacheMap;

  if (cacheMap === undefined) {
    return new Map();
  }

  if (cacheMap !== null) {
    var cacheFunctions = ['get', 'set', 'delete', 'clear'];
    var missingFunctions = cacheFunctions.filter(function (fnName) {
      return cacheMap && typeof cacheMap[fnName] !== 'function';
    });

    if (missingFunctions.length !== 0) {
      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));
    }
  }

  return cacheMap;
} // Private


function isArrayLike(x) {
  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
}

var dataloader = DataLoader;

var Loader = /** @class */ (function () {
    function Loader() {
    }
    Loader.get = function (func, options) {
        if (options === void 0) { options = {
            cacheKeyFn: function (_a) {
                var id = _a[0];
                return id;
            }
        }; }
        var loader = new dataloader(function (ids) {
            return func(ids);
        }, options);
        loader.load = loader.load.bind(loader);
        return loader;
    };
    return Loader;
}());

var BaseMiddleware = /** @class */ (function () {
    function BaseMiddleware(app) {
        autoBind(this);
        this.app = app;
    }
    return BaseMiddleware;
}());

var BaseMiddlewareGql = /** @class */ (function () {
    function BaseMiddlewareGql(app) {
        autoBind(this);
        this.app = app;
    }
    return BaseMiddlewareGql;
}());

export { FindClause, BaseComponent, BaseService, BaseRouter, BaseResolver, BaseType, RouteType, Loader, BaseMiddleware, BaseMiddlewareGql };
//# sourceMappingURL=xc-core-ts.es5.js.map
