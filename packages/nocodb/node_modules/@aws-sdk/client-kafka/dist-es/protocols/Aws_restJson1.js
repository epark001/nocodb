import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, resolvedPath as __resolvedPath, take, withBaseException, } from "@smithy/smithy-client";
import { KafkaServiceException as __BaseException } from "../models/KafkaServiceException";
import { BadRequestException, ConflictException, ForbiddenException, InternalServerErrorException, NotFoundException, ServiceUnavailableException, TooManyRequestsException, UnauthorizedException, } from "../models/models_0";
export const se_BatchAssociateScramSecretCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/scram-secrets";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        secretArnList: [, (_) => _json(_), `SecretArnList`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_BatchDisassociateScramSecretCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/scram-secrets";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        secretArnList: [, (_) => _json(_), `SecretArnList`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateClusterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters";
    let body;
    body = JSON.stringify(take(input, {
        brokerNodeGroupInfo: [, (_) => se_BrokerNodeGroupInfo(_, context), `BrokerNodeGroupInfo`],
        clientAuthentication: [, (_) => se_ClientAuthentication(_, context), `ClientAuthentication`],
        clusterName: [, , `ClusterName`],
        configurationInfo: [, (_) => se_ConfigurationInfo(_, context), `ConfigurationInfo`],
        encryptionInfo: [, (_) => se_EncryptionInfo(_, context), `EncryptionInfo`],
        enhancedMonitoring: [, , `EnhancedMonitoring`],
        kafkaVersion: [, , `KafkaVersion`],
        loggingInfo: [, (_) => se_LoggingInfo(_, context), `LoggingInfo`],
        numberOfBrokerNodes: [, , `NumberOfBrokerNodes`],
        openMonitoring: [, (_) => se_OpenMonitoringInfo(_, context), `OpenMonitoring`],
        storageMode: [, , `StorageMode`],
        tags: [, (_) => _json(_), `Tags`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateClusterV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/clusters";
    let body;
    body = JSON.stringify(take(input, {
        clusterName: [, , `ClusterName`],
        provisioned: [, (_) => se_ProvisionedRequest(_, context), `Provisioned`],
        serverless: [, (_) => se_ServerlessRequest(_, context), `Serverless`],
        tags: [, (_) => _json(_), `Tags`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations";
    let body;
    body = JSON.stringify(take(input, {
        description: [, , `Description`],
        kafkaVersions: [, (_) => _json(_), `KafkaVersions`],
        name: [, , `Name`],
        serverProperties: [, (_) => context.base64Encoder(_), `ServerProperties`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateVpcConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/vpc-connection";
    let body;
    body = JSON.stringify(take(input, {
        authentication: [, , `Authentication`],
        clientSubnets: [, (_) => _json(_), `ClientSubnets`],
        securityGroups: [, (_) => _json(_), `SecurityGroups`],
        tags: [, (_) => _json(_), `Tags`],
        targetClusterArn: [, , `TargetClusterArn`],
        vpcId: [, , `VpcId`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteClusterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = map({
        currentVersion: [, input.CurrentVersion],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_DeleteClusterPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations/{Arn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteVpcConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/vpc-connection/{Arn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DescribeClusterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DescribeClusterOperationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/operations/{ClusterOperationArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterOperationArn", () => input.ClusterOperationArn, "{ClusterOperationArn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DescribeClusterOperationV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/operations/{ClusterOperationArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterOperationArn", () => input.ClusterOperationArn, "{ClusterOperationArn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DescribeClusterV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/clusters/{ClusterArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DescribeConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations/{Arn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DescribeConfigurationRevisionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v1/configurations/{Arn}/revisions/{Revision}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "Revision", () => input.Revision.toString(), "{Revision}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DescribeVpcConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/vpc-connection/{Arn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetBootstrapBrokersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v1/clusters/{ClusterArn}/bootstrap-brokers";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetClusterPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetCompatibleKafkaVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/compatible-kafka-versions";
    const query = map({
        clusterArn: [, input.ClusterArn],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListClientVpcConnectionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v1/clusters/{ClusterArn}/client-vpc-connections";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListClusterOperationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/operations";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListClusterOperationsV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/clusters/{ClusterArn}/operations";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListClustersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters";
    const query = map({
        clusterNameFilter: [, input.ClusterNameFilter],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListClustersV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/clusters";
    const query = map({
        clusterNameFilter: [, input.ClusterNameFilter],
        clusterTypeFilter: [, input.ClusterTypeFilter],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListConfigurationRevisionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations/{Arn}/revisions";
    resolvedPath = __resolvedPath(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListConfigurationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations";
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListKafkaVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/kafka-versions";
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListNodesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/nodes";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListScramSecretsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/scram-secrets";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/tags/{ResourceArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_ListVpcConnectionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/vpc-connections";
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_PutClusterPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        currentVersion: [, , `CurrentVersion`],
        policy: [, , `Policy`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_RebootBrokerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/reboot-broker";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        brokerIds: [, (_) => _json(_), `BrokerIds`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_RejectClientVpcConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v1/clusters/{ClusterArn}/client-vpc-connection";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        vpcConnectionArn: [, , `VpcConnectionArn`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/tags/{ResourceArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: [, (_) => _json(_), `Tags`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/tags/{ResourceArn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    const query = map({
        tagKeys: [
            __expectNonNull(input.TagKeys, `TagKeys`) != null,
            () => (input.TagKeys || []).map((_entry) => _entry),
        ],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_UpdateBrokerCountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/nodes/count";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        currentVersion: [, , `CurrentVersion`],
        targetNumberOfBrokerNodes: [, , `TargetNumberOfBrokerNodes`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateBrokerStorageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/nodes/storage";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        currentVersion: [, , `CurrentVersion`],
        targetBrokerEBSVolumeInfo: [, (_) => se___listOfBrokerEBSVolumeInfo(_, context), `TargetBrokerEBSVolumeInfo`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateBrokerTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/nodes/type";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        currentVersion: [, , `CurrentVersion`],
        targetInstanceType: [, , `TargetInstanceType`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateClusterConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/configuration";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        configurationInfo: [, (_) => se_ConfigurationInfo(_, context), `ConfigurationInfo`],
        currentVersion: [, , `CurrentVersion`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateClusterKafkaVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/version";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        configurationInfo: [, (_) => se_ConfigurationInfo(_, context), `ConfigurationInfo`],
        currentVersion: [, , `CurrentVersion`],
        targetKafkaVersion: [, , `TargetKafkaVersion`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations/{Arn}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [, , `Description`],
        serverProperties: [, (_) => context.base64Encoder(_), `ServerProperties`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateConnectivityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/connectivity";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        connectivityInfo: [, (_) => se_ConnectivityInfo(_, context), `ConnectivityInfo`],
        currentVersion: [, , `CurrentVersion`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateMonitoringCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/monitoring";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        currentVersion: [, , `CurrentVersion`],
        enhancedMonitoring: [, , `EnhancedMonitoring`],
        loggingInfo: [, (_) => se_LoggingInfo(_, context), `LoggingInfo`],
        openMonitoring: [, (_) => se_OpenMonitoringInfo(_, context), `OpenMonitoring`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateSecurityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/security";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientAuthentication: [, (_) => se_ClientAuthentication(_, context), `ClientAuthentication`],
        currentVersion: [, , `CurrentVersion`],
        encryptionInfo: [, (_) => se_EncryptionInfo(_, context), `EncryptionInfo`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateStorageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/storage";
    resolvedPath = __resolvedPath(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        currentVersion: [, , `CurrentVersion`],
        provisionedThroughput: [, (_) => se_ProvisionedThroughput(_, context), `ProvisionedThroughput`],
        storageMode: [, , `StorageMode`],
        volumeSizeGB: [, , `VolumeSizeGB`],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const de_BatchAssociateScramSecretCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchAssociateScramSecretCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        UnprocessedScramSecrets: [, (_) => de___listOfUnprocessedScramSecret(_, context), `unprocessedScramSecrets`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_BatchAssociateScramSecretCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_BatchDisassociateScramSecretCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchDisassociateScramSecretCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        UnprocessedScramSecrets: [, (_) => de___listOfUnprocessedScramSecret(_, context), `unprocessedScramSecrets`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_BatchDisassociateScramSecretCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateClusterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateClusterCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterName: [, __expectString, `clusterName`],
        State: [, __expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateClusterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.kafka#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateClusterV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateClusterV2CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterName: [, __expectString, `clusterName`],
        ClusterType: [, __expectString, `clusterType`],
        State: [, __expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateClusterV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.kafka#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        LatestRevision: [, (_) => de_ConfigurationRevision(_, context), `latestRevision`],
        Name: [, __expectString, `name`],
        State: [, __expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.kafka#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateVpcConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateVpcConnectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Authentication: [, __expectString, `authentication`],
        ClientSubnets: [, _json, `clientSubnets`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        SecurityGroups: [, _json, `securityGroups`],
        State: [, __expectString, `state`],
        Tags: [, _json, `tags`],
        VpcConnectionArn: [, __expectString, `vpcConnectionArn`],
        VpcId: [, __expectString, `vpcId`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateVpcConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteClusterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteClusterCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        State: [, __expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DeleteClusterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteClusterPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteClusterPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteClusterPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        State: [, __expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DeleteConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteVpcConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteVpcConnectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        State: [, __expectString, `state`],
        VpcConnectionArn: [, __expectString, `vpcConnectionArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DeleteVpcConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeClusterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeClusterCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterInfo: [, (_) => de_ClusterInfo(_, context), `clusterInfo`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeClusterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeClusterOperationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeClusterOperationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterOperationInfo: [, (_) => de_ClusterOperationInfo(_, context), `clusterOperationInfo`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeClusterOperationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeClusterOperationV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeClusterOperationV2CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterOperationInfo: [, (_) => de_ClusterOperationV2(_, context), `clusterOperationInfo`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeClusterOperationV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeClusterV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeClusterV2CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterInfo: [, (_) => de_Cluster(_, context), `clusterInfo`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeClusterV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        Description: [, __expectString, `description`],
        KafkaVersions: [, _json, `kafkaVersions`],
        LatestRevision: [, (_) => de_ConfigurationRevision(_, context), `latestRevision`],
        Name: [, __expectString, `name`],
        State: [, __expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeConfigurationRevisionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeConfigurationRevisionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        Description: [, __expectString, `description`],
        Revision: [, __expectLong, `revision`],
        ServerProperties: [, context.base64Decoder, `serverProperties`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeConfigurationRevisionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeVpcConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeVpcConnectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Authentication: [, __expectString, `authentication`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        SecurityGroups: [, _json, `securityGroups`],
        State: [, __expectString, `state`],
        Subnets: [, _json, `subnets`],
        Tags: [, _json, `tags`],
        TargetClusterArn: [, __expectString, `targetClusterArn`],
        VpcConnectionArn: [, __expectString, `vpcConnectionArn`],
        VpcId: [, __expectString, `vpcId`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeVpcConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetBootstrapBrokersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBootstrapBrokersCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BootstrapBrokerString: [, __expectString, `bootstrapBrokerString`],
        BootstrapBrokerStringPublicSaslIam: [, __expectString, `bootstrapBrokerStringPublicSaslIam`],
        BootstrapBrokerStringPublicSaslScram: [, __expectString, `bootstrapBrokerStringPublicSaslScram`],
        BootstrapBrokerStringPublicTls: [, __expectString, `bootstrapBrokerStringPublicTls`],
        BootstrapBrokerStringSaslIam: [, __expectString, `bootstrapBrokerStringSaslIam`],
        BootstrapBrokerStringSaslScram: [, __expectString, `bootstrapBrokerStringSaslScram`],
        BootstrapBrokerStringTls: [, __expectString, `bootstrapBrokerStringTls`],
        BootstrapBrokerStringVpcConnectivitySaslIam: [, __expectString, `bootstrapBrokerStringVpcConnectivitySaslIam`],
        BootstrapBrokerStringVpcConnectivitySaslScram: [, __expectString, `bootstrapBrokerStringVpcConnectivitySaslScram`],
        BootstrapBrokerStringVpcConnectivityTls: [, __expectString, `bootstrapBrokerStringVpcConnectivityTls`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetBootstrapBrokersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.kafka#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetClusterPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetClusterPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CurrentVersion: [, __expectString, `currentVersion`],
        Policy: [, __expectString, `policy`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetClusterPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetCompatibleKafkaVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCompatibleKafkaVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CompatibleKafkaVersions: [, (_) => de___listOfCompatibleKafkaVersion(_, context), `compatibleKafkaVersions`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetCompatibleKafkaVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListClientVpcConnectionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClientVpcConnectionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClientVpcConnections: [, (_) => de___listOfClientVpcConnection(_, context), `clientVpcConnections`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListClientVpcConnectionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListClusterOperationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClusterOperationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterOperationInfoList: [, (_) => de___listOfClusterOperationInfo(_, context), `clusterOperationInfoList`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListClusterOperationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListClusterOperationsV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClusterOperationsV2CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterOperationInfoList: [, (_) => de___listOfClusterOperationV2Summary(_, context), `clusterOperationInfoList`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListClusterOperationsV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListClustersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClustersCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterInfoList: [, (_) => de___listOfClusterInfo(_, context), `clusterInfoList`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListClustersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListClustersV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClustersV2CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterInfoList: [, (_) => de___listOfCluster(_, context), `clusterInfoList`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListClustersV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListConfigurationRevisionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListConfigurationRevisionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: [, __expectString, `nextToken`],
        Revisions: [, (_) => de___listOfConfigurationRevision(_, context), `revisions`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListConfigurationRevisionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListConfigurationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Configurations: [, (_) => de___listOfConfiguration(_, context), `configurations`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListKafkaVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListKafkaVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        KafkaVersions: [, (_) => de___listOfKafkaVersion(_, context), `kafkaVersions`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListKafkaVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListNodesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListNodesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: [, __expectString, `nextToken`],
        NodeInfoList: [, (_) => de___listOfNodeInfo(_, context), `nodeInfoList`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListNodesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListScramSecretsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListScramSecretsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: [, __expectString, `nextToken`],
        SecretArnList: [, _json, `secretArnList`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListScramSecretsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListVpcConnectionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListVpcConnectionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: [, __expectString, `nextToken`],
        VpcConnections: [, (_) => de___listOfVpcConnection(_, context), `vpcConnections`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListVpcConnectionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_PutClusterPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutClusterPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CurrentVersion: [, __expectString, `currentVersion`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_PutClusterPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RebootBrokerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RebootBrokerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_RebootBrokerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RejectClientVpcConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RejectClientVpcConnectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_RejectClientVpcConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateBrokerCountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBrokerCountCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateBrokerCountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateBrokerStorageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBrokerStorageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateBrokerStorageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateBrokerTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBrokerTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateBrokerTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateClusterConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateClusterConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateClusterConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateClusterKafkaVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateClusterKafkaVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateClusterKafkaVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        LatestRevision: [, (_) => de_ConfigurationRevision(_, context), `latestRevision`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateConnectivityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateConnectivityCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateConnectivityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateMonitoringCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateMonitoringCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateMonitoringCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateSecurityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateSecurityCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateSecurityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateStorageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStorageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterOperationArn: [, __expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateStorageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        InvalidParameter: [, __expectString, `invalidParameter`],
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        InvalidParameter: [, __expectString, `invalidParameter`],
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ForbiddenExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        InvalidParameter: [, __expectString, `invalidParameter`],
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ForbiddenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerErrorExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        InvalidParameter: [, __expectString, `invalidParameter`],
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new InternalServerErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        InvalidParameter: [, __expectString, `invalidParameter`],
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        InvalidParameter: [, __expectString, `invalidParameter`],
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        InvalidParameter: [, __expectString, `invalidParameter`],
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        InvalidParameter: [, __expectString, `invalidParameter`],
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se___listOfBrokerEBSVolumeInfo = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_BrokerEBSVolumeInfo(entry, context);
    });
};
const se___listOfVpcConfig = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_VpcConfig(entry, context);
    });
};
const se_BrokerEBSVolumeInfo = (input, context) => {
    return take(input, {
        kafkaBrokerNodeId: [, , `KafkaBrokerNodeId`],
        provisionedThroughput: [, (_) => se_ProvisionedThroughput(_, context), `ProvisionedThroughput`],
        volumeSizeGB: [, , `VolumeSizeGB`],
    });
};
const se_BrokerLogs = (input, context) => {
    return take(input, {
        cloudWatchLogs: [, (_) => se_CloudWatchLogs(_, context), `CloudWatchLogs`],
        firehose: [, (_) => se_Firehose(_, context), `Firehose`],
        s3: [, (_) => se_S3(_, context), `S3`],
    });
};
const se_BrokerNodeGroupInfo = (input, context) => {
    return take(input, {
        brokerAZDistribution: [, , `BrokerAZDistribution`],
        clientSubnets: [, _json, `ClientSubnets`],
        connectivityInfo: [, (_) => se_ConnectivityInfo(_, context), `ConnectivityInfo`],
        instanceType: [, , `InstanceType`],
        securityGroups: [, _json, `SecurityGroups`],
        storageInfo: [, (_) => se_StorageInfo(_, context), `StorageInfo`],
        zoneIds: [, _json, `ZoneIds`],
    });
};
const se_ClientAuthentication = (input, context) => {
    return take(input, {
        sasl: [, (_) => se_Sasl(_, context), `Sasl`],
        tls: [, (_) => se_Tls(_, context), `Tls`],
        unauthenticated: [, (_) => se_Unauthenticated(_, context), `Unauthenticated`],
    });
};
const se_CloudWatchLogs = (input, context) => {
    return take(input, {
        enabled: [, , `Enabled`],
        logGroup: [, , `LogGroup`],
    });
};
const se_ConfigurationInfo = (input, context) => {
    return take(input, {
        arn: [, , `Arn`],
        revision: [, , `Revision`],
    });
};
const se_ConnectivityInfo = (input, context) => {
    return take(input, {
        publicAccess: [, (_) => se_PublicAccess(_, context), `PublicAccess`],
        vpcConnectivity: [, (_) => se_VpcConnectivity(_, context), `VpcConnectivity`],
    });
};
const se_EBSStorageInfo = (input, context) => {
    return take(input, {
        provisionedThroughput: [, (_) => se_ProvisionedThroughput(_, context), `ProvisionedThroughput`],
        volumeSize: [, , `VolumeSize`],
    });
};
const se_EncryptionAtRest = (input, context) => {
    return take(input, {
        dataVolumeKMSKeyId: [, , `DataVolumeKMSKeyId`],
    });
};
const se_EncryptionInfo = (input, context) => {
    return take(input, {
        encryptionAtRest: [, (_) => se_EncryptionAtRest(_, context), `EncryptionAtRest`],
        encryptionInTransit: [, (_) => se_EncryptionInTransit(_, context), `EncryptionInTransit`],
    });
};
const se_EncryptionInTransit = (input, context) => {
    return take(input, {
        clientBroker: [, , `ClientBroker`],
        inCluster: [, , `InCluster`],
    });
};
const se_Firehose = (input, context) => {
    return take(input, {
        deliveryStream: [, , `DeliveryStream`],
        enabled: [, , `Enabled`],
    });
};
const se_Iam = (input, context) => {
    return take(input, {
        enabled: [, , `Enabled`],
    });
};
const se_JmxExporterInfo = (input, context) => {
    return take(input, {
        enabledInBroker: [, , `EnabledInBroker`],
    });
};
const se_LoggingInfo = (input, context) => {
    return take(input, {
        brokerLogs: [, (_) => se_BrokerLogs(_, context), `BrokerLogs`],
    });
};
const se_NodeExporterInfo = (input, context) => {
    return take(input, {
        enabledInBroker: [, , `EnabledInBroker`],
    });
};
const se_OpenMonitoringInfo = (input, context) => {
    return take(input, {
        prometheus: [, (_) => se_PrometheusInfo(_, context), `Prometheus`],
    });
};
const se_PrometheusInfo = (input, context) => {
    return take(input, {
        jmxExporter: [, (_) => se_JmxExporterInfo(_, context), `JmxExporter`],
        nodeExporter: [, (_) => se_NodeExporterInfo(_, context), `NodeExporter`],
    });
};
const se_ProvisionedRequest = (input, context) => {
    return take(input, {
        brokerNodeGroupInfo: [, (_) => se_BrokerNodeGroupInfo(_, context), `BrokerNodeGroupInfo`],
        clientAuthentication: [, (_) => se_ClientAuthentication(_, context), `ClientAuthentication`],
        configurationInfo: [, (_) => se_ConfigurationInfo(_, context), `ConfigurationInfo`],
        encryptionInfo: [, (_) => se_EncryptionInfo(_, context), `EncryptionInfo`],
        enhancedMonitoring: [, , `EnhancedMonitoring`],
        kafkaVersion: [, , `KafkaVersion`],
        loggingInfo: [, (_) => se_LoggingInfo(_, context), `LoggingInfo`],
        numberOfBrokerNodes: [, , `NumberOfBrokerNodes`],
        openMonitoring: [, (_) => se_OpenMonitoringInfo(_, context), `OpenMonitoring`],
        storageMode: [, , `StorageMode`],
    });
};
const se_ProvisionedThroughput = (input, context) => {
    return take(input, {
        enabled: [, , `Enabled`],
        volumeThroughput: [, , `VolumeThroughput`],
    });
};
const se_PublicAccess = (input, context) => {
    return take(input, {
        type: [, , `Type`],
    });
};
const se_S3 = (input, context) => {
    return take(input, {
        bucket: [, , `Bucket`],
        enabled: [, , `Enabled`],
        prefix: [, , `Prefix`],
    });
};
const se_Sasl = (input, context) => {
    return take(input, {
        iam: [, (_) => se_Iam(_, context), `Iam`],
        scram: [, (_) => se_Scram(_, context), `Scram`],
    });
};
const se_Scram = (input, context) => {
    return take(input, {
        enabled: [, , `Enabled`],
    });
};
const se_ServerlessClientAuthentication = (input, context) => {
    return take(input, {
        sasl: [, (_) => se_ServerlessSasl(_, context), `Sasl`],
    });
};
const se_ServerlessRequest = (input, context) => {
    return take(input, {
        clientAuthentication: [, (_) => se_ServerlessClientAuthentication(_, context), `ClientAuthentication`],
        vpcConfigs: [, (_) => se___listOfVpcConfig(_, context), `VpcConfigs`],
    });
};
const se_ServerlessSasl = (input, context) => {
    return take(input, {
        iam: [, (_) => se_Iam(_, context), `Iam`],
    });
};
const se_StorageInfo = (input, context) => {
    return take(input, {
        ebsStorageInfo: [, (_) => se_EBSStorageInfo(_, context), `EbsStorageInfo`],
    });
};
const se_Tls = (input, context) => {
    return take(input, {
        certificateAuthorityArnList: [, _json, `CertificateAuthorityArnList`],
        enabled: [, , `Enabled`],
    });
};
const se_Unauthenticated = (input, context) => {
    return take(input, {
        enabled: [, , `Enabled`],
    });
};
const se_VpcConfig = (input, context) => {
    return take(input, {
        securityGroupIds: [, _json, `SecurityGroupIds`],
        subnetIds: [, _json, `SubnetIds`],
    });
};
const se_VpcConnectivity = (input, context) => {
    return take(input, {
        clientAuthentication: [, (_) => se_VpcConnectivityClientAuthentication(_, context), `ClientAuthentication`],
    });
};
const se_VpcConnectivityClientAuthentication = (input, context) => {
    return take(input, {
        sasl: [, (_) => se_VpcConnectivitySasl(_, context), `Sasl`],
        tls: [, (_) => se_VpcConnectivityTls(_, context), `Tls`],
    });
};
const se_VpcConnectivityIam = (input, context) => {
    return take(input, {
        enabled: [, , `Enabled`],
    });
};
const se_VpcConnectivitySasl = (input, context) => {
    return take(input, {
        iam: [, (_) => se_VpcConnectivityIam(_, context), `Iam`],
        scram: [, (_) => se_VpcConnectivityScram(_, context), `Scram`],
    });
};
const se_VpcConnectivityScram = (input, context) => {
    return take(input, {
        enabled: [, , `Enabled`],
    });
};
const se_VpcConnectivityTls = (input, context) => {
    return take(input, {
        enabled: [, , `Enabled`],
    });
};
const de___listOfBrokerEBSVolumeInfo = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BrokerEBSVolumeInfo(entry, context);
    });
    return retVal;
};
const de___listOfClientVpcConnection = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClientVpcConnection(entry, context);
    });
    return retVal;
};
const de___listOfCluster = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Cluster(entry, context);
    });
    return retVal;
};
const de___listOfClusterInfo = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterInfo(entry, context);
    });
    return retVal;
};
const de___listOfClusterOperationInfo = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterOperationInfo(entry, context);
    });
    return retVal;
};
const de___listOfClusterOperationStep = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterOperationStep(entry, context);
    });
    return retVal;
};
const de___listOfClusterOperationV2Summary = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterOperationV2Summary(entry, context);
    });
    return retVal;
};
const de___listOfCompatibleKafkaVersion = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CompatibleKafkaVersion(entry, context);
    });
    return retVal;
};
const de___listOfConfiguration = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Configuration(entry, context);
    });
    return retVal;
};
const de___listOfConfigurationRevision = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ConfigurationRevision(entry, context);
    });
    return retVal;
};
const de___listOfKafkaVersion = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KafkaVersion(entry, context);
    });
    return retVal;
};
const de___listOfNodeInfo = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NodeInfo(entry, context);
    });
    return retVal;
};
const de___listOfUnprocessedScramSecret = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UnprocessedScramSecret(entry, context);
    });
    return retVal;
};
const de___listOfVpcConfig = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcConfig(entry, context);
    });
    return retVal;
};
const de___listOfVpcConnection = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcConnection(entry, context);
    });
    return retVal;
};
const de_BrokerEBSVolumeInfo = (output, context) => {
    return take(output, {
        KafkaBrokerNodeId: [, __expectString, `kafkaBrokerNodeId`],
        ProvisionedThroughput: [, (_) => de_ProvisionedThroughput(_, context), `provisionedThroughput`],
        VolumeSizeGB: [, __expectInt32, `volumeSizeGB`],
    });
};
const de_BrokerLogs = (output, context) => {
    return take(output, {
        CloudWatchLogs: [, (_) => de_CloudWatchLogs(_, context), `cloudWatchLogs`],
        Firehose: [, (_) => de_Firehose(_, context), `firehose`],
        S3: [, (_) => de_S3(_, context), `s3`],
    });
};
const de_BrokerNodeGroupInfo = (output, context) => {
    return take(output, {
        BrokerAZDistribution: [, __expectString, `brokerAZDistribution`],
        ClientSubnets: [, _json, `clientSubnets`],
        ConnectivityInfo: [, (_) => de_ConnectivityInfo(_, context), `connectivityInfo`],
        InstanceType: [, __expectString, `instanceType`],
        SecurityGroups: [, _json, `securityGroups`],
        StorageInfo: [, (_) => de_StorageInfo(_, context), `storageInfo`],
        ZoneIds: [, _json, `zoneIds`],
    });
};
const de_BrokerNodeInfo = (output, context) => {
    return take(output, {
        AttachedENIId: [, __expectString, `attachedENIId`],
        BrokerId: [, __limitedParseDouble, `brokerId`],
        ClientSubnet: [, __expectString, `clientSubnet`],
        ClientVpcIpAddress: [, __expectString, `clientVpcIpAddress`],
        CurrentBrokerSoftwareInfo: [, (_) => de_BrokerSoftwareInfo(_, context), `currentBrokerSoftwareInfo`],
        Endpoints: [, _json, `endpoints`],
    });
};
const de_BrokerSoftwareInfo = (output, context) => {
    return take(output, {
        ConfigurationArn: [, __expectString, `configurationArn`],
        ConfigurationRevision: [, __expectLong, `configurationRevision`],
        KafkaVersion: [, __expectString, `kafkaVersion`],
    });
};
const de_ClientAuthentication = (output, context) => {
    return take(output, {
        Sasl: [, (_) => de_Sasl(_, context), `sasl`],
        Tls: [, (_) => de_Tls(_, context), `tls`],
        Unauthenticated: [, (_) => de_Unauthenticated(_, context), `unauthenticated`],
    });
};
const de_ClientVpcConnection = (output, context) => {
    return take(output, {
        Authentication: [, __expectString, `authentication`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        Owner: [, __expectString, `owner`],
        State: [, __expectString, `state`],
        VpcConnectionArn: [, __expectString, `vpcConnectionArn`],
    });
};
const de_CloudWatchLogs = (output, context) => {
    return take(output, {
        Enabled: [, __expectBoolean, `enabled`],
        LogGroup: [, __expectString, `logGroup`],
    });
};
const de_Cluster = (output, context) => {
    return take(output, {
        ActiveOperationArn: [, __expectString, `activeOperationArn`],
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterName: [, __expectString, `clusterName`],
        ClusterType: [, __expectString, `clusterType`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        CurrentVersion: [, __expectString, `currentVersion`],
        Provisioned: [, (_) => de_Provisioned(_, context), `provisioned`],
        Serverless: [, (_) => de_Serverless(_, context), `serverless`],
        State: [, __expectString, `state`],
        StateInfo: [, (_) => de_StateInfo(_, context), `stateInfo`],
        Tags: [, _json, `tags`],
    });
};
const de_ClusterInfo = (output, context) => {
    return take(output, {
        ActiveOperationArn: [, __expectString, `activeOperationArn`],
        BrokerNodeGroupInfo: [, (_) => de_BrokerNodeGroupInfo(_, context), `brokerNodeGroupInfo`],
        ClientAuthentication: [, (_) => de_ClientAuthentication(_, context), `clientAuthentication`],
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterName: [, __expectString, `clusterName`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        CurrentBrokerSoftwareInfo: [, (_) => de_BrokerSoftwareInfo(_, context), `currentBrokerSoftwareInfo`],
        CurrentVersion: [, __expectString, `currentVersion`],
        EncryptionInfo: [, (_) => de_EncryptionInfo(_, context), `encryptionInfo`],
        EnhancedMonitoring: [, __expectString, `enhancedMonitoring`],
        LoggingInfo: [, (_) => de_LoggingInfo(_, context), `loggingInfo`],
        NumberOfBrokerNodes: [, __expectInt32, `numberOfBrokerNodes`],
        OpenMonitoring: [, (_) => de_OpenMonitoring(_, context), `openMonitoring`],
        State: [, __expectString, `state`],
        StateInfo: [, (_) => de_StateInfo(_, context), `stateInfo`],
        StorageMode: [, __expectString, `storageMode`],
        Tags: [, _json, `tags`],
        ZookeeperConnectString: [, __expectString, `zookeeperConnectString`],
        ZookeeperConnectStringTls: [, __expectString, `zookeeperConnectStringTls`],
    });
};
const de_ClusterOperationInfo = (output, context) => {
    return take(output, {
        ClientRequestId: [, __expectString, `clientRequestId`],
        ClusterArn: [, __expectString, `clusterArn`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        EndTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `endTime`],
        ErrorInfo: [, (_) => de_ErrorInfo(_, context), `errorInfo`],
        OperationArn: [, __expectString, `operationArn`],
        OperationState: [, __expectString, `operationState`],
        OperationSteps: [, (_) => de___listOfClusterOperationStep(_, context), `operationSteps`],
        OperationType: [, __expectString, `operationType`],
        SourceClusterInfo: [, (_) => de_MutableClusterInfo(_, context), `sourceClusterInfo`],
        TargetClusterInfo: [, (_) => de_MutableClusterInfo(_, context), `targetClusterInfo`],
        VpcConnectionInfo: [, (_) => de_VpcConnectionInfo(_, context), `vpcConnectionInfo`],
    });
};
const de_ClusterOperationStep = (output, context) => {
    return take(output, {
        StepInfo: [, (_) => de_ClusterOperationStepInfo(_, context), `stepInfo`],
        StepName: [, __expectString, `stepName`],
    });
};
const de_ClusterOperationStepInfo = (output, context) => {
    return take(output, {
        StepStatus: [, __expectString, `stepStatus`],
    });
};
const de_ClusterOperationV2 = (output, context) => {
    return take(output, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterType: [, __expectString, `clusterType`],
        EndTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `endTime`],
        ErrorInfo: [, (_) => de_ErrorInfo(_, context), `errorInfo`],
        OperationArn: [, __expectString, `operationArn`],
        OperationState: [, __expectString, `operationState`],
        OperationType: [, __expectString, `operationType`],
        Provisioned: [, (_) => de_ClusterOperationV2Provisioned(_, context), `provisioned`],
        Serverless: [, (_) => de_ClusterOperationV2Serverless(_, context), `serverless`],
        StartTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `startTime`],
    });
};
const de_ClusterOperationV2Provisioned = (output, context) => {
    return take(output, {
        OperationSteps: [, (_) => de___listOfClusterOperationStep(_, context), `operationSteps`],
        SourceClusterInfo: [, (_) => de_MutableClusterInfo(_, context), `sourceClusterInfo`],
        TargetClusterInfo: [, (_) => de_MutableClusterInfo(_, context), `targetClusterInfo`],
        VpcConnectionInfo: [, (_) => de_VpcConnectionInfo(_, context), `vpcConnectionInfo`],
    });
};
const de_ClusterOperationV2Serverless = (output, context) => {
    return take(output, {
        VpcConnectionInfo: [, (_) => de_VpcConnectionInfoServerless(_, context), `vpcConnectionInfo`],
    });
};
const de_ClusterOperationV2Summary = (output, context) => {
    return take(output, {
        ClusterArn: [, __expectString, `clusterArn`],
        ClusterType: [, __expectString, `clusterType`],
        EndTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `endTime`],
        OperationArn: [, __expectString, `operationArn`],
        OperationState: [, __expectString, `operationState`],
        OperationType: [, __expectString, `operationType`],
        StartTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `startTime`],
    });
};
const de_CompatibleKafkaVersion = (output, context) => {
    return take(output, {
        SourceVersion: [, __expectString, `sourceVersion`],
        TargetVersions: [, _json, `targetVersions`],
    });
};
const de_Configuration = (output, context) => {
    return take(output, {
        Arn: [, __expectString, `arn`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        Description: [, __expectString, `description`],
        KafkaVersions: [, _json, `kafkaVersions`],
        LatestRevision: [, (_) => de_ConfigurationRevision(_, context), `latestRevision`],
        Name: [, __expectString, `name`],
        State: [, __expectString, `state`],
    });
};
const de_ConfigurationInfo = (output, context) => {
    return take(output, {
        Arn: [, __expectString, `arn`],
        Revision: [, __expectLong, `revision`],
    });
};
const de_ConfigurationRevision = (output, context) => {
    return take(output, {
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        Description: [, __expectString, `description`],
        Revision: [, __expectLong, `revision`],
    });
};
const de_ConnectivityInfo = (output, context) => {
    return take(output, {
        PublicAccess: [, (_) => de_PublicAccess(_, context), `publicAccess`],
        VpcConnectivity: [, (_) => de_VpcConnectivity(_, context), `vpcConnectivity`],
    });
};
const de_EBSStorageInfo = (output, context) => {
    return take(output, {
        ProvisionedThroughput: [, (_) => de_ProvisionedThroughput(_, context), `provisionedThroughput`],
        VolumeSize: [, __expectInt32, `volumeSize`],
    });
};
const de_EncryptionAtRest = (output, context) => {
    return take(output, {
        DataVolumeKMSKeyId: [, __expectString, `dataVolumeKMSKeyId`],
    });
};
const de_EncryptionInfo = (output, context) => {
    return take(output, {
        EncryptionAtRest: [, (_) => de_EncryptionAtRest(_, context), `encryptionAtRest`],
        EncryptionInTransit: [, (_) => de_EncryptionInTransit(_, context), `encryptionInTransit`],
    });
};
const de_EncryptionInTransit = (output, context) => {
    return take(output, {
        ClientBroker: [, __expectString, `clientBroker`],
        InCluster: [, __expectBoolean, `inCluster`],
    });
};
const de_ErrorInfo = (output, context) => {
    return take(output, {
        ErrorCode: [, __expectString, `errorCode`],
        ErrorString: [, __expectString, `errorString`],
    });
};
const de_Firehose = (output, context) => {
    return take(output, {
        DeliveryStream: [, __expectString, `deliveryStream`],
        Enabled: [, __expectBoolean, `enabled`],
    });
};
const de_Iam = (output, context) => {
    return take(output, {
        Enabled: [, __expectBoolean, `enabled`],
    });
};
const de_JmxExporter = (output, context) => {
    return take(output, {
        EnabledInBroker: [, __expectBoolean, `enabledInBroker`],
    });
};
const de_JmxExporterInfo = (output, context) => {
    return take(output, {
        EnabledInBroker: [, __expectBoolean, `enabledInBroker`],
    });
};
const de_KafkaVersion = (output, context) => {
    return take(output, {
        Status: [, __expectString, `status`],
        Version: [, __expectString, `version`],
    });
};
const de_LoggingInfo = (output, context) => {
    return take(output, {
        BrokerLogs: [, (_) => de_BrokerLogs(_, context), `brokerLogs`],
    });
};
const de_MutableClusterInfo = (output, context) => {
    return take(output, {
        BrokerEBSVolumeInfo: [, (_) => de___listOfBrokerEBSVolumeInfo(_, context), `brokerEBSVolumeInfo`],
        ClientAuthentication: [, (_) => de_ClientAuthentication(_, context), `clientAuthentication`],
        ConfigurationInfo: [, (_) => de_ConfigurationInfo(_, context), `configurationInfo`],
        ConnectivityInfo: [, (_) => de_ConnectivityInfo(_, context), `connectivityInfo`],
        EncryptionInfo: [, (_) => de_EncryptionInfo(_, context), `encryptionInfo`],
        EnhancedMonitoring: [, __expectString, `enhancedMonitoring`],
        InstanceType: [, __expectString, `instanceType`],
        KafkaVersion: [, __expectString, `kafkaVersion`],
        LoggingInfo: [, (_) => de_LoggingInfo(_, context), `loggingInfo`],
        NumberOfBrokerNodes: [, __expectInt32, `numberOfBrokerNodes`],
        OpenMonitoring: [, (_) => de_OpenMonitoring(_, context), `openMonitoring`],
        StorageMode: [, __expectString, `storageMode`],
    });
};
const de_NodeExporter = (output, context) => {
    return take(output, {
        EnabledInBroker: [, __expectBoolean, `enabledInBroker`],
    });
};
const de_NodeExporterInfo = (output, context) => {
    return take(output, {
        EnabledInBroker: [, __expectBoolean, `enabledInBroker`],
    });
};
const de_NodeInfo = (output, context) => {
    return take(output, {
        AddedToClusterTime: [, __expectString, `addedToClusterTime`],
        BrokerNodeInfo: [, (_) => de_BrokerNodeInfo(_, context), `brokerNodeInfo`],
        InstanceType: [, __expectString, `instanceType`],
        NodeARN: [, __expectString, `nodeARN`],
        NodeType: [, __expectString, `nodeType`],
        ZookeeperNodeInfo: [, (_) => de_ZookeeperNodeInfo(_, context), `zookeeperNodeInfo`],
    });
};
const de_OpenMonitoring = (output, context) => {
    return take(output, {
        Prometheus: [, (_) => de_Prometheus(_, context), `prometheus`],
    });
};
const de_OpenMonitoringInfo = (output, context) => {
    return take(output, {
        Prometheus: [, (_) => de_PrometheusInfo(_, context), `prometheus`],
    });
};
const de_Prometheus = (output, context) => {
    return take(output, {
        JmxExporter: [, (_) => de_JmxExporter(_, context), `jmxExporter`],
        NodeExporter: [, (_) => de_NodeExporter(_, context), `nodeExporter`],
    });
};
const de_PrometheusInfo = (output, context) => {
    return take(output, {
        JmxExporter: [, (_) => de_JmxExporterInfo(_, context), `jmxExporter`],
        NodeExporter: [, (_) => de_NodeExporterInfo(_, context), `nodeExporter`],
    });
};
const de_Provisioned = (output, context) => {
    return take(output, {
        BrokerNodeGroupInfo: [, (_) => de_BrokerNodeGroupInfo(_, context), `brokerNodeGroupInfo`],
        ClientAuthentication: [, (_) => de_ClientAuthentication(_, context), `clientAuthentication`],
        CurrentBrokerSoftwareInfo: [, (_) => de_BrokerSoftwareInfo(_, context), `currentBrokerSoftwareInfo`],
        EncryptionInfo: [, (_) => de_EncryptionInfo(_, context), `encryptionInfo`],
        EnhancedMonitoring: [, __expectString, `enhancedMonitoring`],
        LoggingInfo: [, (_) => de_LoggingInfo(_, context), `loggingInfo`],
        NumberOfBrokerNodes: [, __expectInt32, `numberOfBrokerNodes`],
        OpenMonitoring: [, (_) => de_OpenMonitoringInfo(_, context), `openMonitoring`],
        StorageMode: [, __expectString, `storageMode`],
        ZookeeperConnectString: [, __expectString, `zookeeperConnectString`],
        ZookeeperConnectStringTls: [, __expectString, `zookeeperConnectStringTls`],
    });
};
const de_ProvisionedThroughput = (output, context) => {
    return take(output, {
        Enabled: [, __expectBoolean, `enabled`],
        VolumeThroughput: [, __expectInt32, `volumeThroughput`],
    });
};
const de_PublicAccess = (output, context) => {
    return take(output, {
        Type: [, __expectString, `type`],
    });
};
const de_S3 = (output, context) => {
    return take(output, {
        Bucket: [, __expectString, `bucket`],
        Enabled: [, __expectBoolean, `enabled`],
        Prefix: [, __expectString, `prefix`],
    });
};
const de_Sasl = (output, context) => {
    return take(output, {
        Iam: [, (_) => de_Iam(_, context), `iam`],
        Scram: [, (_) => de_Scram(_, context), `scram`],
    });
};
const de_Scram = (output, context) => {
    return take(output, {
        Enabled: [, __expectBoolean, `enabled`],
    });
};
const de_Serverless = (output, context) => {
    return take(output, {
        ClientAuthentication: [, (_) => de_ServerlessClientAuthentication(_, context), `clientAuthentication`],
        VpcConfigs: [, (_) => de___listOfVpcConfig(_, context), `vpcConfigs`],
    });
};
const de_ServerlessClientAuthentication = (output, context) => {
    return take(output, {
        Sasl: [, (_) => de_ServerlessSasl(_, context), `sasl`],
    });
};
const de_ServerlessSasl = (output, context) => {
    return take(output, {
        Iam: [, (_) => de_Iam(_, context), `iam`],
    });
};
const de_StateInfo = (output, context) => {
    return take(output, {
        Code: [, __expectString, `code`],
        Message: [, __expectString, `message`],
    });
};
const de_StorageInfo = (output, context) => {
    return take(output, {
        EbsStorageInfo: [, (_) => de_EBSStorageInfo(_, context), `ebsStorageInfo`],
    });
};
const de_Tls = (output, context) => {
    return take(output, {
        CertificateAuthorityArnList: [, _json, `certificateAuthorityArnList`],
        Enabled: [, __expectBoolean, `enabled`],
    });
};
const de_Unauthenticated = (output, context) => {
    return take(output, {
        Enabled: [, __expectBoolean, `enabled`],
    });
};
const de_UnprocessedScramSecret = (output, context) => {
    return take(output, {
        ErrorCode: [, __expectString, `errorCode`],
        ErrorMessage: [, __expectString, `errorMessage`],
        SecretArn: [, __expectString, `secretArn`],
    });
};
const de_UserIdentity = (output, context) => {
    return take(output, {
        PrincipalId: [, __expectString, `principalId`],
        Type: [, __expectString, `type`],
    });
};
const de_VpcConfig = (output, context) => {
    return take(output, {
        SecurityGroupIds: [, _json, `securityGroupIds`],
        SubnetIds: [, _json, `subnetIds`],
    });
};
const de_VpcConnection = (output, context) => {
    return take(output, {
        Authentication: [, __expectString, `authentication`],
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        State: [, __expectString, `state`],
        TargetClusterArn: [, __expectString, `targetClusterArn`],
        VpcConnectionArn: [, __expectString, `vpcConnectionArn`],
        VpcId: [, __expectString, `vpcId`],
    });
};
const de_VpcConnectionInfo = (output, context) => {
    return take(output, {
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        Owner: [, __expectString, `owner`],
        UserIdentity: [, (_) => de_UserIdentity(_, context), `userIdentity`],
        VpcConnectionArn: [, __expectString, `vpcConnectionArn`],
    });
};
const de_VpcConnectionInfoServerless = (output, context) => {
    return take(output, {
        CreationTime: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `creationTime`],
        Owner: [, __expectString, `owner`],
        UserIdentity: [, (_) => de_UserIdentity(_, context), `userIdentity`],
        VpcConnectionArn: [, __expectString, `vpcConnectionArn`],
    });
};
const de_VpcConnectivity = (output, context) => {
    return take(output, {
        ClientAuthentication: [, (_) => de_VpcConnectivityClientAuthentication(_, context), `clientAuthentication`],
    });
};
const de_VpcConnectivityClientAuthentication = (output, context) => {
    return take(output, {
        Sasl: [, (_) => de_VpcConnectivitySasl(_, context), `sasl`],
        Tls: [, (_) => de_VpcConnectivityTls(_, context), `tls`],
    });
};
const de_VpcConnectivityIam = (output, context) => {
    return take(output, {
        Enabled: [, __expectBoolean, `enabled`],
    });
};
const de_VpcConnectivitySasl = (output, context) => {
    return take(output, {
        Iam: [, (_) => de_VpcConnectivityIam(_, context), `iam`],
        Scram: [, (_) => de_VpcConnectivityScram(_, context), `scram`],
    });
};
const de_VpcConnectivityScram = (output, context) => {
    return take(output, {
        Enabled: [, __expectBoolean, `enabled`],
    });
};
const de_VpcConnectivityTls = (output, context) => {
    return take(output, {
        Enabled: [, __expectBoolean, `enabled`],
    });
};
const de_ZookeeperNodeInfo = (output, context) => {
    return take(output, {
        AttachedENIId: [, __expectString, `attachedENIId`],
        ClientVpcIpAddress: [, __expectString, `clientVpcIpAddress`],
        Endpoints: [, _json, `endpoints`],
        ZookeeperId: [, __limitedParseDouble, `zookeeperId`],
        ZookeeperVersion: [, __expectString, `zookeeperVersion`],
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
