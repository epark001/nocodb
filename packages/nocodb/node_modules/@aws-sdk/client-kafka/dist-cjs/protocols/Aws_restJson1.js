"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.de_CreateClusterCommand = exports.de_BatchDisassociateScramSecretCommand = exports.de_BatchAssociateScramSecretCommand = exports.se_UpdateStorageCommand = exports.se_UpdateSecurityCommand = exports.se_UpdateMonitoringCommand = exports.se_UpdateConnectivityCommand = exports.se_UpdateConfigurationCommand = exports.se_UpdateClusterKafkaVersionCommand = exports.se_UpdateClusterConfigurationCommand = exports.se_UpdateBrokerTypeCommand = exports.se_UpdateBrokerStorageCommand = exports.se_UpdateBrokerCountCommand = exports.se_UntagResourceCommand = exports.se_TagResourceCommand = exports.se_RejectClientVpcConnectionCommand = exports.se_RebootBrokerCommand = exports.se_PutClusterPolicyCommand = exports.se_ListVpcConnectionsCommand = exports.se_ListTagsForResourceCommand = exports.se_ListScramSecretsCommand = exports.se_ListNodesCommand = exports.se_ListKafkaVersionsCommand = exports.se_ListConfigurationsCommand = exports.se_ListConfigurationRevisionsCommand = exports.se_ListClustersV2Command = exports.se_ListClustersCommand = exports.se_ListClusterOperationsV2Command = exports.se_ListClusterOperationsCommand = exports.se_ListClientVpcConnectionsCommand = exports.se_GetCompatibleKafkaVersionsCommand = exports.se_GetClusterPolicyCommand = exports.se_GetBootstrapBrokersCommand = exports.se_DescribeVpcConnectionCommand = exports.se_DescribeConfigurationRevisionCommand = exports.se_DescribeConfigurationCommand = exports.se_DescribeClusterV2Command = exports.se_DescribeClusterOperationV2Command = exports.se_DescribeClusterOperationCommand = exports.se_DescribeClusterCommand = exports.se_DeleteVpcConnectionCommand = exports.se_DeleteConfigurationCommand = exports.se_DeleteClusterPolicyCommand = exports.se_DeleteClusterCommand = exports.se_CreateVpcConnectionCommand = exports.se_CreateConfigurationCommand = exports.se_CreateClusterV2Command = exports.se_CreateClusterCommand = exports.se_BatchDisassociateScramSecretCommand = exports.se_BatchAssociateScramSecretCommand = void 0;
exports.de_UpdateStorageCommand = exports.de_UpdateSecurityCommand = exports.de_UpdateMonitoringCommand = exports.de_UpdateConnectivityCommand = exports.de_UpdateConfigurationCommand = exports.de_UpdateClusterKafkaVersionCommand = exports.de_UpdateClusterConfigurationCommand = exports.de_UpdateBrokerTypeCommand = exports.de_UpdateBrokerStorageCommand = exports.de_UpdateBrokerCountCommand = exports.de_UntagResourceCommand = exports.de_TagResourceCommand = exports.de_RejectClientVpcConnectionCommand = exports.de_RebootBrokerCommand = exports.de_PutClusterPolicyCommand = exports.de_ListVpcConnectionsCommand = exports.de_ListTagsForResourceCommand = exports.de_ListScramSecretsCommand = exports.de_ListNodesCommand = exports.de_ListKafkaVersionsCommand = exports.de_ListConfigurationsCommand = exports.de_ListConfigurationRevisionsCommand = exports.de_ListClustersV2Command = exports.de_ListClustersCommand = exports.de_ListClusterOperationsV2Command = exports.de_ListClusterOperationsCommand = exports.de_ListClientVpcConnectionsCommand = exports.de_GetCompatibleKafkaVersionsCommand = exports.de_GetClusterPolicyCommand = exports.de_GetBootstrapBrokersCommand = exports.de_DescribeVpcConnectionCommand = exports.de_DescribeConfigurationRevisionCommand = exports.de_DescribeConfigurationCommand = exports.de_DescribeClusterV2Command = exports.de_DescribeClusterOperationV2Command = exports.de_DescribeClusterOperationCommand = exports.de_DescribeClusterCommand = exports.de_DeleteVpcConnectionCommand = exports.de_DeleteConfigurationCommand = exports.de_DeleteClusterPolicyCommand = exports.de_DeleteClusterCommand = exports.de_CreateVpcConnectionCommand = exports.de_CreateConfigurationCommand = exports.de_CreateClusterV2Command = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const KafkaServiceException_1 = require("../models/KafkaServiceException");
const models_0_1 = require("../models/models_0");
const se_BatchAssociateScramSecretCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/scram-secrets";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        secretArnList: [, (_) => (0, smithy_client_1._json)(_), `SecretArnList`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchAssociateScramSecretCommand = se_BatchAssociateScramSecretCommand;
const se_BatchDisassociateScramSecretCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/scram-secrets";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        secretArnList: [, (_) => (0, smithy_client_1._json)(_), `SecretArnList`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_BatchDisassociateScramSecretCommand = se_BatchDisassociateScramSecretCommand;
const se_CreateClusterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        brokerNodeGroupInfo: [, (_) => se_BrokerNodeGroupInfo(_, context), `BrokerNodeGroupInfo`],
        clientAuthentication: [, (_) => se_ClientAuthentication(_, context), `ClientAuthentication`],
        clusterName: [, , `ClusterName`],
        configurationInfo: [, (_) => se_ConfigurationInfo(_, context), `ConfigurationInfo`],
        encryptionInfo: [, (_) => se_EncryptionInfo(_, context), `EncryptionInfo`],
        enhancedMonitoring: [, , `EnhancedMonitoring`],
        kafkaVersion: [, , `KafkaVersion`],
        loggingInfo: [, (_) => se_LoggingInfo(_, context), `LoggingInfo`],
        numberOfBrokerNodes: [, , `NumberOfBrokerNodes`],
        openMonitoring: [, (_) => se_OpenMonitoringInfo(_, context), `OpenMonitoring`],
        storageMode: [, , `StorageMode`],
        tags: [, (_) => (0, smithy_client_1._json)(_), `Tags`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateClusterCommand = se_CreateClusterCommand;
const se_CreateClusterV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/clusters";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        clusterName: [, , `ClusterName`],
        provisioned: [, (_) => se_ProvisionedRequest(_, context), `Provisioned`],
        serverless: [, (_) => se_ServerlessRequest(_, context), `Serverless`],
        tags: [, (_) => (0, smithy_client_1._json)(_), `Tags`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateClusterV2Command = se_CreateClusterV2Command;
const se_CreateConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [, , `Description`],
        kafkaVersions: [, (_) => (0, smithy_client_1._json)(_), `KafkaVersions`],
        name: [, , `Name`],
        serverProperties: [, (_) => context.base64Encoder(_), `ServerProperties`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateConfigurationCommand = se_CreateConfigurationCommand;
const se_CreateVpcConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/vpc-connection";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authentication: [, , `Authentication`],
        clientSubnets: [, (_) => (0, smithy_client_1._json)(_), `ClientSubnets`],
        securityGroups: [, (_) => (0, smithy_client_1._json)(_), `SecurityGroups`],
        tags: [, (_) => (0, smithy_client_1._json)(_), `Tags`],
        targetClusterArn: [, , `TargetClusterArn`],
        vpcId: [, , `VpcId`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateVpcConnectionCommand = se_CreateVpcConnectionCommand;
const se_DeleteClusterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = (0, smithy_client_1.map)({
        currentVersion: [, input.CurrentVersion],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteClusterCommand = se_DeleteClusterCommand;
const se_DeleteClusterPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/policy";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteClusterPolicyCommand = se_DeleteClusterPolicyCommand;
const se_DeleteConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations/{Arn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteConfigurationCommand = se_DeleteConfigurationCommand;
const se_DeleteVpcConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/vpc-connection/{Arn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteVpcConnectionCommand = se_DeleteVpcConnectionCommand;
const se_DescribeClusterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeClusterCommand = se_DescribeClusterCommand;
const se_DescribeClusterOperationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/operations/{ClusterOperationArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterOperationArn", () => input.ClusterOperationArn, "{ClusterOperationArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeClusterOperationCommand = se_DescribeClusterOperationCommand;
const se_DescribeClusterOperationV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/operations/{ClusterOperationArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterOperationArn", () => input.ClusterOperationArn, "{ClusterOperationArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeClusterOperationV2Command = se_DescribeClusterOperationV2Command;
const se_DescribeClusterV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/clusters/{ClusterArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeClusterV2Command = se_DescribeClusterV2Command;
const se_DescribeConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations/{Arn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeConfigurationCommand = se_DescribeConfigurationCommand;
const se_DescribeConfigurationRevisionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v1/configurations/{Arn}/revisions/{Revision}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Revision", () => input.Revision.toString(), "{Revision}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeConfigurationRevisionCommand = se_DescribeConfigurationRevisionCommand;
const se_DescribeVpcConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/vpc-connection/{Arn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeVpcConnectionCommand = se_DescribeVpcConnectionCommand;
const se_GetBootstrapBrokersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v1/clusters/{ClusterArn}/bootstrap-brokers";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetBootstrapBrokersCommand = se_GetBootstrapBrokersCommand;
const se_GetClusterPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/policy";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetClusterPolicyCommand = se_GetClusterPolicyCommand;
const se_GetCompatibleKafkaVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/compatible-kafka-versions";
    const query = (0, smithy_client_1.map)({
        clusterArn: [, input.ClusterArn],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetCompatibleKafkaVersionsCommand = se_GetCompatibleKafkaVersionsCommand;
const se_ListClientVpcConnectionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v1/clusters/{ClusterArn}/client-vpc-connections";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListClientVpcConnectionsCommand = se_ListClientVpcConnectionsCommand;
const se_ListClusterOperationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/operations";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListClusterOperationsCommand = se_ListClusterOperationsCommand;
const se_ListClusterOperationsV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/clusters/{ClusterArn}/operations";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListClusterOperationsV2Command = se_ListClusterOperationsV2Command;
const se_ListClustersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters";
    const query = (0, smithy_client_1.map)({
        clusterNameFilter: [, input.ClusterNameFilter],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListClustersCommand = se_ListClustersCommand;
const se_ListClustersV2Command = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/api/v2/clusters";
    const query = (0, smithy_client_1.map)({
        clusterNameFilter: [, input.ClusterNameFilter],
        clusterTypeFilter: [, input.ClusterTypeFilter],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListClustersV2Command = se_ListClustersV2Command;
const se_ListConfigurationRevisionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations/{Arn}/revisions";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListConfigurationRevisionsCommand = se_ListConfigurationRevisionsCommand;
const se_ListConfigurationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListConfigurationsCommand = se_ListConfigurationsCommand;
const se_ListKafkaVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/kafka-versions";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListKafkaVersionsCommand = se_ListKafkaVersionsCommand;
const se_ListNodesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/nodes";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListNodesCommand = se_ListNodesCommand;
const se_ListScramSecretsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/scram-secrets";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListScramSecretsCommand = se_ListScramSecretsCommand;
const se_ListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/tags/{ResourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ListTagsForResourceCommand = se_ListTagsForResourceCommand;
const se_ListVpcConnectionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/vpc-connections";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListVpcConnectionsCommand = se_ListVpcConnectionsCommand;
const se_PutClusterPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/policy";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        currentVersion: [, , `CurrentVersion`],
        policy: [, , `Policy`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_PutClusterPolicyCommand = se_PutClusterPolicyCommand;
const se_RebootBrokerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/reboot-broker";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        brokerIds: [, (_) => (0, smithy_client_1._json)(_), `BrokerIds`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RebootBrokerCommand = se_RebootBrokerCommand;
const se_RejectClientVpcConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v1/clusters/{ClusterArn}/client-vpc-connection";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        vpcConnectionArn: [, , `VpcConnectionArn`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RejectClientVpcConnectionCommand = se_RejectClientVpcConnectionCommand;
const se_TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/tags/{ResourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        tags: [, (_) => (0, smithy_client_1._json)(_), `Tags`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/tags/{ResourceArn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    const query = (0, smithy_client_1.map)({
        tagKeys: [
            (0, smithy_client_1.expectNonNull)(input.TagKeys, `TagKeys`) != null,
            () => (input.TagKeys || []).map((_entry) => _entry),
        ],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateBrokerCountCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/nodes/count";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        currentVersion: [, , `CurrentVersion`],
        targetNumberOfBrokerNodes: [, , `TargetNumberOfBrokerNodes`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateBrokerCountCommand = se_UpdateBrokerCountCommand;
const se_UpdateBrokerStorageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/nodes/storage";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        currentVersion: [, , `CurrentVersion`],
        targetBrokerEBSVolumeInfo: [, (_) => se___listOfBrokerEBSVolumeInfo(_, context), `TargetBrokerEBSVolumeInfo`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateBrokerStorageCommand = se_UpdateBrokerStorageCommand;
const se_UpdateBrokerTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/nodes/type";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        currentVersion: [, , `CurrentVersion`],
        targetInstanceType: [, , `TargetInstanceType`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateBrokerTypeCommand = se_UpdateBrokerTypeCommand;
const se_UpdateClusterConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/configuration";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        configurationInfo: [, (_) => se_ConfigurationInfo(_, context), `ConfigurationInfo`],
        currentVersion: [, , `CurrentVersion`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateClusterConfigurationCommand = se_UpdateClusterConfigurationCommand;
const se_UpdateClusterKafkaVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/version";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        configurationInfo: [, (_) => se_ConfigurationInfo(_, context), `ConfigurationInfo`],
        currentVersion: [, , `CurrentVersion`],
        targetKafkaVersion: [, , `TargetKafkaVersion`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateClusterKafkaVersionCommand = se_UpdateClusterKafkaVersionCommand;
const se_UpdateConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/configurations/{Arn}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Arn", () => input.Arn, "{Arn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [, , `Description`],
        serverProperties: [, (_) => context.base64Encoder(_), `ServerProperties`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateConfigurationCommand = se_UpdateConfigurationCommand;
const se_UpdateConnectivityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/connectivity";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        connectivityInfo: [, (_) => se_ConnectivityInfo(_, context), `ConnectivityInfo`],
        currentVersion: [, , `CurrentVersion`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateConnectivityCommand = se_UpdateConnectivityCommand;
const se_UpdateMonitoringCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/monitoring";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        currentVersion: [, , `CurrentVersion`],
        enhancedMonitoring: [, , `EnhancedMonitoring`],
        loggingInfo: [, (_) => se_LoggingInfo(_, context), `LoggingInfo`],
        openMonitoring: [, (_) => se_OpenMonitoringInfo(_, context), `OpenMonitoring`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateMonitoringCommand = se_UpdateMonitoringCommand;
const se_UpdateSecurityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/security";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        clientAuthentication: [, (_) => se_ClientAuthentication(_, context), `ClientAuthentication`],
        currentVersion: [, , `CurrentVersion`],
        encryptionInfo: [, (_) => se_EncryptionInfo(_, context), `EncryptionInfo`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateSecurityCommand = se_UpdateSecurityCommand;
const se_UpdateStorageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/clusters/{ClusterArn}/storage";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ClusterArn", () => input.ClusterArn, "{ClusterArn}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        currentVersion: [, , `CurrentVersion`],
        provisionedThroughput: [, (_) => se_ProvisionedThroughput(_, context), `ProvisionedThroughput`],
        storageMode: [, , `StorageMode`],
        volumeSizeGB: [, , `VolumeSizeGB`],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateStorageCommand = se_UpdateStorageCommand;
const de_BatchAssociateScramSecretCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchAssociateScramSecretCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        UnprocessedScramSecrets: [, (_) => de___listOfUnprocessedScramSecret(_, context), `unprocessedScramSecrets`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchAssociateScramSecretCommand = de_BatchAssociateScramSecretCommand;
const de_BatchAssociateScramSecretCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchDisassociateScramSecretCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_BatchDisassociateScramSecretCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        UnprocessedScramSecrets: [, (_) => de___listOfUnprocessedScramSecret(_, context), `unprocessedScramSecrets`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_BatchDisassociateScramSecretCommand = de_BatchDisassociateScramSecretCommand;
const de_BatchDisassociateScramSecretCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateClusterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateClusterCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterName: [, smithy_client_1.expectString, `clusterName`],
        State: [, smithy_client_1.expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateClusterCommand = de_CreateClusterCommand;
const de_CreateClusterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.kafka#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateClusterV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateClusterV2CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterName: [, smithy_client_1.expectString, `clusterName`],
        ClusterType: [, smithy_client_1.expectString, `clusterType`],
        State: [, smithy_client_1.expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateClusterV2Command = de_CreateClusterV2Command;
const de_CreateClusterV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.kafka#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Arn: [, smithy_client_1.expectString, `arn`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        LatestRevision: [, (_) => de_ConfigurationRevision(_, context), `latestRevision`],
        Name: [, smithy_client_1.expectString, `name`],
        State: [, smithy_client_1.expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateConfigurationCommand = de_CreateConfigurationCommand;
const de_CreateConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.kafka#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateVpcConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateVpcConnectionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Authentication: [, smithy_client_1.expectString, `authentication`],
        ClientSubnets: [, smithy_client_1._json, `clientSubnets`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        SecurityGroups: [, smithy_client_1._json, `securityGroups`],
        State: [, smithy_client_1.expectString, `state`],
        Tags: [, smithy_client_1._json, `tags`],
        VpcConnectionArn: [, smithy_client_1.expectString, `vpcConnectionArn`],
        VpcId: [, smithy_client_1.expectString, `vpcId`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateVpcConnectionCommand = de_CreateVpcConnectionCommand;
const de_CreateVpcConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteClusterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteClusterCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        State: [, smithy_client_1.expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DeleteClusterCommand = de_DeleteClusterCommand;
const de_DeleteClusterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteClusterPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteClusterPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteClusterPolicyCommand = de_DeleteClusterPolicyCommand;
const de_DeleteClusterPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Arn: [, smithy_client_1.expectString, `arn`],
        State: [, smithy_client_1.expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DeleteConfigurationCommand = de_DeleteConfigurationCommand;
const de_DeleteConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteVpcConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteVpcConnectionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        State: [, smithy_client_1.expectString, `state`],
        VpcConnectionArn: [, smithy_client_1.expectString, `vpcConnectionArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DeleteVpcConnectionCommand = de_DeleteVpcConnectionCommand;
const de_DeleteVpcConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeClusterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeClusterCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterInfo: [, (_) => de_ClusterInfo(_, context), `clusterInfo`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeClusterCommand = de_DescribeClusterCommand;
const de_DescribeClusterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeClusterOperationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeClusterOperationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterOperationInfo: [, (_) => de_ClusterOperationInfo(_, context), `clusterOperationInfo`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeClusterOperationCommand = de_DescribeClusterOperationCommand;
const de_DescribeClusterOperationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeClusterOperationV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeClusterOperationV2CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterOperationInfo: [, (_) => de_ClusterOperationV2(_, context), `clusterOperationInfo`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeClusterOperationV2Command = de_DescribeClusterOperationV2Command;
const de_DescribeClusterOperationV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeClusterV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeClusterV2CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterInfo: [, (_) => de_Cluster(_, context), `clusterInfo`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeClusterV2Command = de_DescribeClusterV2Command;
const de_DescribeClusterV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Arn: [, smithy_client_1.expectString, `arn`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        Description: [, smithy_client_1.expectString, `description`],
        KafkaVersions: [, smithy_client_1._json, `kafkaVersions`],
        LatestRevision: [, (_) => de_ConfigurationRevision(_, context), `latestRevision`],
        Name: [, smithy_client_1.expectString, `name`],
        State: [, smithy_client_1.expectString, `state`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeConfigurationCommand = de_DescribeConfigurationCommand;
const de_DescribeConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeConfigurationRevisionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeConfigurationRevisionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Arn: [, smithy_client_1.expectString, `arn`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        Description: [, smithy_client_1.expectString, `description`],
        Revision: [, smithy_client_1.expectLong, `revision`],
        ServerProperties: [, context.base64Decoder, `serverProperties`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeConfigurationRevisionCommand = de_DescribeConfigurationRevisionCommand;
const de_DescribeConfigurationRevisionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeVpcConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeVpcConnectionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Authentication: [, smithy_client_1.expectString, `authentication`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        SecurityGroups: [, smithy_client_1._json, `securityGroups`],
        State: [, smithy_client_1.expectString, `state`],
        Subnets: [, smithy_client_1._json, `subnets`],
        Tags: [, smithy_client_1._json, `tags`],
        TargetClusterArn: [, smithy_client_1.expectString, `targetClusterArn`],
        VpcConnectionArn: [, smithy_client_1.expectString, `vpcConnectionArn`],
        VpcId: [, smithy_client_1.expectString, `vpcId`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeVpcConnectionCommand = de_DescribeVpcConnectionCommand;
const de_DescribeVpcConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetBootstrapBrokersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBootstrapBrokersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        BootstrapBrokerString: [, smithy_client_1.expectString, `bootstrapBrokerString`],
        BootstrapBrokerStringPublicSaslIam: [, smithy_client_1.expectString, `bootstrapBrokerStringPublicSaslIam`],
        BootstrapBrokerStringPublicSaslScram: [, smithy_client_1.expectString, `bootstrapBrokerStringPublicSaslScram`],
        BootstrapBrokerStringPublicTls: [, smithy_client_1.expectString, `bootstrapBrokerStringPublicTls`],
        BootstrapBrokerStringSaslIam: [, smithy_client_1.expectString, `bootstrapBrokerStringSaslIam`],
        BootstrapBrokerStringSaslScram: [, smithy_client_1.expectString, `bootstrapBrokerStringSaslScram`],
        BootstrapBrokerStringTls: [, smithy_client_1.expectString, `bootstrapBrokerStringTls`],
        BootstrapBrokerStringVpcConnectivitySaslIam: [, smithy_client_1.expectString, `bootstrapBrokerStringVpcConnectivitySaslIam`],
        BootstrapBrokerStringVpcConnectivitySaslScram: [, smithy_client_1.expectString, `bootstrapBrokerStringVpcConnectivitySaslScram`],
        BootstrapBrokerStringVpcConnectivityTls: [, smithy_client_1.expectString, `bootstrapBrokerStringVpcConnectivityTls`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetBootstrapBrokersCommand = de_GetBootstrapBrokersCommand;
const de_GetBootstrapBrokersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.kafka#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetClusterPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetClusterPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        CurrentVersion: [, smithy_client_1.expectString, `currentVersion`],
        Policy: [, smithy_client_1.expectString, `policy`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetClusterPolicyCommand = de_GetClusterPolicyCommand;
const de_GetClusterPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetCompatibleKafkaVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCompatibleKafkaVersionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        CompatibleKafkaVersions: [, (_) => de___listOfCompatibleKafkaVersion(_, context), `compatibleKafkaVersions`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetCompatibleKafkaVersionsCommand = de_GetCompatibleKafkaVersionsCommand;
const de_GetCompatibleKafkaVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListClientVpcConnectionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClientVpcConnectionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClientVpcConnections: [, (_) => de___listOfClientVpcConnection(_, context), `clientVpcConnections`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListClientVpcConnectionsCommand = de_ListClientVpcConnectionsCommand;
const de_ListClientVpcConnectionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListClusterOperationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClusterOperationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterOperationInfoList: [, (_) => de___listOfClusterOperationInfo(_, context), `clusterOperationInfoList`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListClusterOperationsCommand = de_ListClusterOperationsCommand;
const de_ListClusterOperationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListClusterOperationsV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClusterOperationsV2CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterOperationInfoList: [, (_) => de___listOfClusterOperationV2Summary(_, context), `clusterOperationInfoList`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListClusterOperationsV2Command = de_ListClusterOperationsV2Command;
const de_ListClusterOperationsV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListClustersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClustersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterInfoList: [, (_) => de___listOfClusterInfo(_, context), `clusterInfoList`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListClustersCommand = de_ListClustersCommand;
const de_ListClustersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListClustersV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListClustersV2CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterInfoList: [, (_) => de___listOfCluster(_, context), `clusterInfoList`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListClustersV2Command = de_ListClustersV2Command;
const de_ListClustersV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListConfigurationRevisionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListConfigurationRevisionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: [, smithy_client_1.expectString, `nextToken`],
        Revisions: [, (_) => de___listOfConfigurationRevision(_, context), `revisions`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListConfigurationRevisionsCommand = de_ListConfigurationRevisionsCommand;
const de_ListConfigurationRevisionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Configurations: [, (_) => de___listOfConfiguration(_, context), `configurations`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListConfigurationsCommand = de_ListConfigurationsCommand;
const de_ListConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListKafkaVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListKafkaVersionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        KafkaVersions: [, (_) => de___listOfKafkaVersion(_, context), `kafkaVersions`],
        NextToken: [, smithy_client_1.expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListKafkaVersionsCommand = de_ListKafkaVersionsCommand;
const de_ListKafkaVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListNodesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListNodesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: [, smithy_client_1.expectString, `nextToken`],
        NodeInfoList: [, (_) => de___listOfNodeInfo(_, context), `nodeInfoList`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListNodesCommand = de_ListNodesCommand;
const de_ListNodesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListScramSecretsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListScramSecretsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: [, smithy_client_1.expectString, `nextToken`],
        SecretArnList: [, smithy_client_1._json, `secretArnList`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListScramSecretsCommand = de_ListScramSecretsCommand;
const de_ListScramSecretsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Tags: [, smithy_client_1._json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListTagsForResourceCommand = de_ListTagsForResourceCommand;
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListVpcConnectionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListVpcConnectionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: [, smithy_client_1.expectString, `nextToken`],
        VpcConnections: [, (_) => de___listOfVpcConnection(_, context), `vpcConnections`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListVpcConnectionsCommand = de_ListVpcConnectionsCommand;
const de_ListVpcConnectionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutClusterPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutClusterPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        CurrentVersion: [, smithy_client_1.expectString, `currentVersion`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_PutClusterPolicyCommand = de_PutClusterPolicyCommand;
const de_PutClusterPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RebootBrokerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RebootBrokerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_RebootBrokerCommand = de_RebootBrokerCommand;
const de_RebootBrokerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RejectClientVpcConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RejectClientVpcConnectionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_RejectClientVpcConnectionCommand = de_RejectClientVpcConnectionCommand;
const de_RejectClientVpcConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateBrokerCountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBrokerCountCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateBrokerCountCommand = de_UpdateBrokerCountCommand;
const de_UpdateBrokerCountCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateBrokerStorageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBrokerStorageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateBrokerStorageCommand = de_UpdateBrokerStorageCommand;
const de_UpdateBrokerStorageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateBrokerTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBrokerTypeCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateBrokerTypeCommand = de_UpdateBrokerTypeCommand;
const de_UpdateBrokerTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateClusterConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateClusterConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateClusterConfigurationCommand = de_UpdateClusterConfigurationCommand;
const de_UpdateClusterConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateClusterKafkaVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateClusterKafkaVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateClusterKafkaVersionCommand = de_UpdateClusterKafkaVersionCommand;
const de_UpdateClusterKafkaVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Arn: [, smithy_client_1.expectString, `arn`],
        LatestRevision: [, (_) => de_ConfigurationRevision(_, context), `latestRevision`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateConfigurationCommand = de_UpdateConfigurationCommand;
const de_UpdateConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateConnectivityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateConnectivityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateConnectivityCommand = de_UpdateConnectivityCommand;
const de_UpdateConnectivityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateMonitoringCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateMonitoringCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateMonitoringCommand = de_UpdateMonitoringCommand;
const de_UpdateMonitoringCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateSecurityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateSecurityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateSecurityCommand = de_UpdateSecurityCommand;
const de_UpdateSecurityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateStorageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStorageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterOperationArn: [, smithy_client_1.expectString, `clusterOperationArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateStorageCommand = de_UpdateStorageCommand;
const de_UpdateStorageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.kafka#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.kafka#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.kafka#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kafka#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.kafka#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.kafka#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.kafka#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(KafkaServiceException_1.KafkaServiceException);
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        InvalidParameter: [, smithy_client_1.expectString, `invalidParameter`],
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        InvalidParameter: [, smithy_client_1.expectString, `invalidParameter`],
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ForbiddenExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        InvalidParameter: [, smithy_client_1.expectString, `invalidParameter`],
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ForbiddenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InternalServerErrorExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        InvalidParameter: [, smithy_client_1.expectString, `invalidParameter`],
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InternalServerErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        InvalidParameter: [, smithy_client_1.expectString, `invalidParameter`],
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        InvalidParameter: [, smithy_client_1.expectString, `invalidParameter`],
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        InvalidParameter: [, smithy_client_1.expectString, `invalidParameter`],
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        InvalidParameter: [, smithy_client_1.expectString, `invalidParameter`],
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const se___listOfBrokerEBSVolumeInfo = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_BrokerEBSVolumeInfo(entry, context);
    });
};
const se___listOfVpcConfig = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_VpcConfig(entry, context);
    });
};
const se_BrokerEBSVolumeInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        kafkaBrokerNodeId: [, , `KafkaBrokerNodeId`],
        provisionedThroughput: [, (_) => se_ProvisionedThroughput(_, context), `ProvisionedThroughput`],
        volumeSizeGB: [, , `VolumeSizeGB`],
    });
};
const se_BrokerLogs = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        cloudWatchLogs: [, (_) => se_CloudWatchLogs(_, context), `CloudWatchLogs`],
        firehose: [, (_) => se_Firehose(_, context), `Firehose`],
        s3: [, (_) => se_S3(_, context), `S3`],
    });
};
const se_BrokerNodeGroupInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        brokerAZDistribution: [, , `BrokerAZDistribution`],
        clientSubnets: [, smithy_client_1._json, `ClientSubnets`],
        connectivityInfo: [, (_) => se_ConnectivityInfo(_, context), `ConnectivityInfo`],
        instanceType: [, , `InstanceType`],
        securityGroups: [, smithy_client_1._json, `SecurityGroups`],
        storageInfo: [, (_) => se_StorageInfo(_, context), `StorageInfo`],
        zoneIds: [, smithy_client_1._json, `ZoneIds`],
    });
};
const se_ClientAuthentication = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        sasl: [, (_) => se_Sasl(_, context), `Sasl`],
        tls: [, (_) => se_Tls(_, context), `Tls`],
        unauthenticated: [, (_) => se_Unauthenticated(_, context), `Unauthenticated`],
    });
};
const se_CloudWatchLogs = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabled: [, , `Enabled`],
        logGroup: [, , `LogGroup`],
    });
};
const se_ConfigurationInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        arn: [, , `Arn`],
        revision: [, , `Revision`],
    });
};
const se_ConnectivityInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        publicAccess: [, (_) => se_PublicAccess(_, context), `PublicAccess`],
        vpcConnectivity: [, (_) => se_VpcConnectivity(_, context), `VpcConnectivity`],
    });
};
const se_EBSStorageInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        provisionedThroughput: [, (_) => se_ProvisionedThroughput(_, context), `ProvisionedThroughput`],
        volumeSize: [, , `VolumeSize`],
    });
};
const se_EncryptionAtRest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        dataVolumeKMSKeyId: [, , `DataVolumeKMSKeyId`],
    });
};
const se_EncryptionInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        encryptionAtRest: [, (_) => se_EncryptionAtRest(_, context), `EncryptionAtRest`],
        encryptionInTransit: [, (_) => se_EncryptionInTransit(_, context), `EncryptionInTransit`],
    });
};
const se_EncryptionInTransit = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        clientBroker: [, , `ClientBroker`],
        inCluster: [, , `InCluster`],
    });
};
const se_Firehose = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        deliveryStream: [, , `DeliveryStream`],
        enabled: [, , `Enabled`],
    });
};
const se_Iam = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabled: [, , `Enabled`],
    });
};
const se_JmxExporterInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabledInBroker: [, , `EnabledInBroker`],
    });
};
const se_LoggingInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        brokerLogs: [, (_) => se_BrokerLogs(_, context), `BrokerLogs`],
    });
};
const se_NodeExporterInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabledInBroker: [, , `EnabledInBroker`],
    });
};
const se_OpenMonitoringInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        prometheus: [, (_) => se_PrometheusInfo(_, context), `Prometheus`],
    });
};
const se_PrometheusInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        jmxExporter: [, (_) => se_JmxExporterInfo(_, context), `JmxExporter`],
        nodeExporter: [, (_) => se_NodeExporterInfo(_, context), `NodeExporter`],
    });
};
const se_ProvisionedRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        brokerNodeGroupInfo: [, (_) => se_BrokerNodeGroupInfo(_, context), `BrokerNodeGroupInfo`],
        clientAuthentication: [, (_) => se_ClientAuthentication(_, context), `ClientAuthentication`],
        configurationInfo: [, (_) => se_ConfigurationInfo(_, context), `ConfigurationInfo`],
        encryptionInfo: [, (_) => se_EncryptionInfo(_, context), `EncryptionInfo`],
        enhancedMonitoring: [, , `EnhancedMonitoring`],
        kafkaVersion: [, , `KafkaVersion`],
        loggingInfo: [, (_) => se_LoggingInfo(_, context), `LoggingInfo`],
        numberOfBrokerNodes: [, , `NumberOfBrokerNodes`],
        openMonitoring: [, (_) => se_OpenMonitoringInfo(_, context), `OpenMonitoring`],
        storageMode: [, , `StorageMode`],
    });
};
const se_ProvisionedThroughput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabled: [, , `Enabled`],
        volumeThroughput: [, , `VolumeThroughput`],
    });
};
const se_PublicAccess = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        type: [, , `Type`],
    });
};
const se_S3 = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        bucket: [, , `Bucket`],
        enabled: [, , `Enabled`],
        prefix: [, , `Prefix`],
    });
};
const se_Sasl = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        iam: [, (_) => se_Iam(_, context), `Iam`],
        scram: [, (_) => se_Scram(_, context), `Scram`],
    });
};
const se_Scram = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabled: [, , `Enabled`],
    });
};
const se_ServerlessClientAuthentication = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        sasl: [, (_) => se_ServerlessSasl(_, context), `Sasl`],
    });
};
const se_ServerlessRequest = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        clientAuthentication: [, (_) => se_ServerlessClientAuthentication(_, context), `ClientAuthentication`],
        vpcConfigs: [, (_) => se___listOfVpcConfig(_, context), `VpcConfigs`],
    });
};
const se_ServerlessSasl = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        iam: [, (_) => se_Iam(_, context), `Iam`],
    });
};
const se_StorageInfo = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        ebsStorageInfo: [, (_) => se_EBSStorageInfo(_, context), `EbsStorageInfo`],
    });
};
const se_Tls = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        certificateAuthorityArnList: [, smithy_client_1._json, `CertificateAuthorityArnList`],
        enabled: [, , `Enabled`],
    });
};
const se_Unauthenticated = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabled: [, , `Enabled`],
    });
};
const se_VpcConfig = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        securityGroupIds: [, smithy_client_1._json, `SecurityGroupIds`],
        subnetIds: [, smithy_client_1._json, `SubnetIds`],
    });
};
const se_VpcConnectivity = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        clientAuthentication: [, (_) => se_VpcConnectivityClientAuthentication(_, context), `ClientAuthentication`],
    });
};
const se_VpcConnectivityClientAuthentication = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        sasl: [, (_) => se_VpcConnectivitySasl(_, context), `Sasl`],
        tls: [, (_) => se_VpcConnectivityTls(_, context), `Tls`],
    });
};
const se_VpcConnectivityIam = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabled: [, , `Enabled`],
    });
};
const se_VpcConnectivitySasl = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        iam: [, (_) => se_VpcConnectivityIam(_, context), `Iam`],
        scram: [, (_) => se_VpcConnectivityScram(_, context), `Scram`],
    });
};
const se_VpcConnectivityScram = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabled: [, , `Enabled`],
    });
};
const se_VpcConnectivityTls = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        enabled: [, , `Enabled`],
    });
};
const de___listOfBrokerEBSVolumeInfo = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BrokerEBSVolumeInfo(entry, context);
    });
    return retVal;
};
const de___listOfClientVpcConnection = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClientVpcConnection(entry, context);
    });
    return retVal;
};
const de___listOfCluster = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Cluster(entry, context);
    });
    return retVal;
};
const de___listOfClusterInfo = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterInfo(entry, context);
    });
    return retVal;
};
const de___listOfClusterOperationInfo = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterOperationInfo(entry, context);
    });
    return retVal;
};
const de___listOfClusterOperationStep = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterOperationStep(entry, context);
    });
    return retVal;
};
const de___listOfClusterOperationV2Summary = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterOperationV2Summary(entry, context);
    });
    return retVal;
};
const de___listOfCompatibleKafkaVersion = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CompatibleKafkaVersion(entry, context);
    });
    return retVal;
};
const de___listOfConfiguration = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Configuration(entry, context);
    });
    return retVal;
};
const de___listOfConfigurationRevision = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ConfigurationRevision(entry, context);
    });
    return retVal;
};
const de___listOfKafkaVersion = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KafkaVersion(entry, context);
    });
    return retVal;
};
const de___listOfNodeInfo = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NodeInfo(entry, context);
    });
    return retVal;
};
const de___listOfUnprocessedScramSecret = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UnprocessedScramSecret(entry, context);
    });
    return retVal;
};
const de___listOfVpcConfig = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcConfig(entry, context);
    });
    return retVal;
};
const de___listOfVpcConnection = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcConnection(entry, context);
    });
    return retVal;
};
const de_BrokerEBSVolumeInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        KafkaBrokerNodeId: [, smithy_client_1.expectString, `kafkaBrokerNodeId`],
        ProvisionedThroughput: [, (_) => de_ProvisionedThroughput(_, context), `provisionedThroughput`],
        VolumeSizeGB: [, smithy_client_1.expectInt32, `volumeSizeGB`],
    });
};
const de_BrokerLogs = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CloudWatchLogs: [, (_) => de_CloudWatchLogs(_, context), `cloudWatchLogs`],
        Firehose: [, (_) => de_Firehose(_, context), `firehose`],
        S3: [, (_) => de_S3(_, context), `s3`],
    });
};
const de_BrokerNodeGroupInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BrokerAZDistribution: [, smithy_client_1.expectString, `brokerAZDistribution`],
        ClientSubnets: [, smithy_client_1._json, `clientSubnets`],
        ConnectivityInfo: [, (_) => de_ConnectivityInfo(_, context), `connectivityInfo`],
        InstanceType: [, smithy_client_1.expectString, `instanceType`],
        SecurityGroups: [, smithy_client_1._json, `securityGroups`],
        StorageInfo: [, (_) => de_StorageInfo(_, context), `storageInfo`],
        ZoneIds: [, smithy_client_1._json, `zoneIds`],
    });
};
const de_BrokerNodeInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AttachedENIId: [, smithy_client_1.expectString, `attachedENIId`],
        BrokerId: [, smithy_client_1.limitedParseDouble, `brokerId`],
        ClientSubnet: [, smithy_client_1.expectString, `clientSubnet`],
        ClientVpcIpAddress: [, smithy_client_1.expectString, `clientVpcIpAddress`],
        CurrentBrokerSoftwareInfo: [, (_) => de_BrokerSoftwareInfo(_, context), `currentBrokerSoftwareInfo`],
        Endpoints: [, smithy_client_1._json, `endpoints`],
    });
};
const de_BrokerSoftwareInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ConfigurationArn: [, smithy_client_1.expectString, `configurationArn`],
        ConfigurationRevision: [, smithy_client_1.expectLong, `configurationRevision`],
        KafkaVersion: [, smithy_client_1.expectString, `kafkaVersion`],
    });
};
const de_ClientAuthentication = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Sasl: [, (_) => de_Sasl(_, context), `sasl`],
        Tls: [, (_) => de_Tls(_, context), `tls`],
        Unauthenticated: [, (_) => de_Unauthenticated(_, context), `unauthenticated`],
    });
};
const de_ClientVpcConnection = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Authentication: [, smithy_client_1.expectString, `authentication`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        Owner: [, smithy_client_1.expectString, `owner`],
        State: [, smithy_client_1.expectString, `state`],
        VpcConnectionArn: [, smithy_client_1.expectString, `vpcConnectionArn`],
    });
};
const de_CloudWatchLogs = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
        LogGroup: [, smithy_client_1.expectString, `logGroup`],
    });
};
const de_Cluster = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ActiveOperationArn: [, smithy_client_1.expectString, `activeOperationArn`],
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterName: [, smithy_client_1.expectString, `clusterName`],
        ClusterType: [, smithy_client_1.expectString, `clusterType`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        CurrentVersion: [, smithy_client_1.expectString, `currentVersion`],
        Provisioned: [, (_) => de_Provisioned(_, context), `provisioned`],
        Serverless: [, (_) => de_Serverless(_, context), `serverless`],
        State: [, smithy_client_1.expectString, `state`],
        StateInfo: [, (_) => de_StateInfo(_, context), `stateInfo`],
        Tags: [, smithy_client_1._json, `tags`],
    });
};
const de_ClusterInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ActiveOperationArn: [, smithy_client_1.expectString, `activeOperationArn`],
        BrokerNodeGroupInfo: [, (_) => de_BrokerNodeGroupInfo(_, context), `brokerNodeGroupInfo`],
        ClientAuthentication: [, (_) => de_ClientAuthentication(_, context), `clientAuthentication`],
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterName: [, smithy_client_1.expectString, `clusterName`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        CurrentBrokerSoftwareInfo: [, (_) => de_BrokerSoftwareInfo(_, context), `currentBrokerSoftwareInfo`],
        CurrentVersion: [, smithy_client_1.expectString, `currentVersion`],
        EncryptionInfo: [, (_) => de_EncryptionInfo(_, context), `encryptionInfo`],
        EnhancedMonitoring: [, smithy_client_1.expectString, `enhancedMonitoring`],
        LoggingInfo: [, (_) => de_LoggingInfo(_, context), `loggingInfo`],
        NumberOfBrokerNodes: [, smithy_client_1.expectInt32, `numberOfBrokerNodes`],
        OpenMonitoring: [, (_) => de_OpenMonitoring(_, context), `openMonitoring`],
        State: [, smithy_client_1.expectString, `state`],
        StateInfo: [, (_) => de_StateInfo(_, context), `stateInfo`],
        StorageMode: [, smithy_client_1.expectString, `storageMode`],
        Tags: [, smithy_client_1._json, `tags`],
        ZookeeperConnectString: [, smithy_client_1.expectString, `zookeeperConnectString`],
        ZookeeperConnectStringTls: [, smithy_client_1.expectString, `zookeeperConnectStringTls`],
    });
};
const de_ClusterOperationInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ClientRequestId: [, smithy_client_1.expectString, `clientRequestId`],
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        EndTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `endTime`],
        ErrorInfo: [, (_) => de_ErrorInfo(_, context), `errorInfo`],
        OperationArn: [, smithy_client_1.expectString, `operationArn`],
        OperationState: [, smithy_client_1.expectString, `operationState`],
        OperationSteps: [, (_) => de___listOfClusterOperationStep(_, context), `operationSteps`],
        OperationType: [, smithy_client_1.expectString, `operationType`],
        SourceClusterInfo: [, (_) => de_MutableClusterInfo(_, context), `sourceClusterInfo`],
        TargetClusterInfo: [, (_) => de_MutableClusterInfo(_, context), `targetClusterInfo`],
        VpcConnectionInfo: [, (_) => de_VpcConnectionInfo(_, context), `vpcConnectionInfo`],
    });
};
const de_ClusterOperationStep = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        StepInfo: [, (_) => de_ClusterOperationStepInfo(_, context), `stepInfo`],
        StepName: [, smithy_client_1.expectString, `stepName`],
    });
};
const de_ClusterOperationStepInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        StepStatus: [, smithy_client_1.expectString, `stepStatus`],
    });
};
const de_ClusterOperationV2 = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterType: [, smithy_client_1.expectString, `clusterType`],
        EndTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `endTime`],
        ErrorInfo: [, (_) => de_ErrorInfo(_, context), `errorInfo`],
        OperationArn: [, smithy_client_1.expectString, `operationArn`],
        OperationState: [, smithy_client_1.expectString, `operationState`],
        OperationType: [, smithy_client_1.expectString, `operationType`],
        Provisioned: [, (_) => de_ClusterOperationV2Provisioned(_, context), `provisioned`],
        Serverless: [, (_) => de_ClusterOperationV2Serverless(_, context), `serverless`],
        StartTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `startTime`],
    });
};
const de_ClusterOperationV2Provisioned = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        OperationSteps: [, (_) => de___listOfClusterOperationStep(_, context), `operationSteps`],
        SourceClusterInfo: [, (_) => de_MutableClusterInfo(_, context), `sourceClusterInfo`],
        TargetClusterInfo: [, (_) => de_MutableClusterInfo(_, context), `targetClusterInfo`],
        VpcConnectionInfo: [, (_) => de_VpcConnectionInfo(_, context), `vpcConnectionInfo`],
    });
};
const de_ClusterOperationV2Serverless = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        VpcConnectionInfo: [, (_) => de_VpcConnectionInfoServerless(_, context), `vpcConnectionInfo`],
    });
};
const de_ClusterOperationV2Summary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ClusterArn: [, smithy_client_1.expectString, `clusterArn`],
        ClusterType: [, smithy_client_1.expectString, `clusterType`],
        EndTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `endTime`],
        OperationArn: [, smithy_client_1.expectString, `operationArn`],
        OperationState: [, smithy_client_1.expectString, `operationState`],
        OperationType: [, smithy_client_1.expectString, `operationType`],
        StartTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `startTime`],
    });
};
const de_CompatibleKafkaVersion = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        SourceVersion: [, smithy_client_1.expectString, `sourceVersion`],
        TargetVersions: [, smithy_client_1._json, `targetVersions`],
    });
};
const de_Configuration = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Arn: [, smithy_client_1.expectString, `arn`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        Description: [, smithy_client_1.expectString, `description`],
        KafkaVersions: [, smithy_client_1._json, `kafkaVersions`],
        LatestRevision: [, (_) => de_ConfigurationRevision(_, context), `latestRevision`],
        Name: [, smithy_client_1.expectString, `name`],
        State: [, smithy_client_1.expectString, `state`],
    });
};
const de_ConfigurationInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Arn: [, smithy_client_1.expectString, `arn`],
        Revision: [, smithy_client_1.expectLong, `revision`],
    });
};
const de_ConfigurationRevision = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        Description: [, smithy_client_1.expectString, `description`],
        Revision: [, smithy_client_1.expectLong, `revision`],
    });
};
const de_ConnectivityInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        PublicAccess: [, (_) => de_PublicAccess(_, context), `publicAccess`],
        VpcConnectivity: [, (_) => de_VpcConnectivity(_, context), `vpcConnectivity`],
    });
};
const de_EBSStorageInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ProvisionedThroughput: [, (_) => de_ProvisionedThroughput(_, context), `provisionedThroughput`],
        VolumeSize: [, smithy_client_1.expectInt32, `volumeSize`],
    });
};
const de_EncryptionAtRest = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DataVolumeKMSKeyId: [, smithy_client_1.expectString, `dataVolumeKMSKeyId`],
    });
};
const de_EncryptionInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        EncryptionAtRest: [, (_) => de_EncryptionAtRest(_, context), `encryptionAtRest`],
        EncryptionInTransit: [, (_) => de_EncryptionInTransit(_, context), `encryptionInTransit`],
    });
};
const de_EncryptionInTransit = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ClientBroker: [, smithy_client_1.expectString, `clientBroker`],
        InCluster: [, smithy_client_1.expectBoolean, `inCluster`],
    });
};
const de_ErrorInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ErrorCode: [, smithy_client_1.expectString, `errorCode`],
        ErrorString: [, smithy_client_1.expectString, `errorString`],
    });
};
const de_Firehose = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        DeliveryStream: [, smithy_client_1.expectString, `deliveryStream`],
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
    });
};
const de_Iam = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
    });
};
const de_JmxExporter = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        EnabledInBroker: [, smithy_client_1.expectBoolean, `enabledInBroker`],
    });
};
const de_JmxExporterInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        EnabledInBroker: [, smithy_client_1.expectBoolean, `enabledInBroker`],
    });
};
const de_KafkaVersion = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Status: [, smithy_client_1.expectString, `status`],
        Version: [, smithy_client_1.expectString, `version`],
    });
};
const de_LoggingInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BrokerLogs: [, (_) => de_BrokerLogs(_, context), `brokerLogs`],
    });
};
const de_MutableClusterInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BrokerEBSVolumeInfo: [, (_) => de___listOfBrokerEBSVolumeInfo(_, context), `brokerEBSVolumeInfo`],
        ClientAuthentication: [, (_) => de_ClientAuthentication(_, context), `clientAuthentication`],
        ConfigurationInfo: [, (_) => de_ConfigurationInfo(_, context), `configurationInfo`],
        ConnectivityInfo: [, (_) => de_ConnectivityInfo(_, context), `connectivityInfo`],
        EncryptionInfo: [, (_) => de_EncryptionInfo(_, context), `encryptionInfo`],
        EnhancedMonitoring: [, smithy_client_1.expectString, `enhancedMonitoring`],
        InstanceType: [, smithy_client_1.expectString, `instanceType`],
        KafkaVersion: [, smithy_client_1.expectString, `kafkaVersion`],
        LoggingInfo: [, (_) => de_LoggingInfo(_, context), `loggingInfo`],
        NumberOfBrokerNodes: [, smithy_client_1.expectInt32, `numberOfBrokerNodes`],
        OpenMonitoring: [, (_) => de_OpenMonitoring(_, context), `openMonitoring`],
        StorageMode: [, smithy_client_1.expectString, `storageMode`],
    });
};
const de_NodeExporter = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        EnabledInBroker: [, smithy_client_1.expectBoolean, `enabledInBroker`],
    });
};
const de_NodeExporterInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        EnabledInBroker: [, smithy_client_1.expectBoolean, `enabledInBroker`],
    });
};
const de_NodeInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AddedToClusterTime: [, smithy_client_1.expectString, `addedToClusterTime`],
        BrokerNodeInfo: [, (_) => de_BrokerNodeInfo(_, context), `brokerNodeInfo`],
        InstanceType: [, smithy_client_1.expectString, `instanceType`],
        NodeARN: [, smithy_client_1.expectString, `nodeARN`],
        NodeType: [, smithy_client_1.expectString, `nodeType`],
        ZookeeperNodeInfo: [, (_) => de_ZookeeperNodeInfo(_, context), `zookeeperNodeInfo`],
    });
};
const de_OpenMonitoring = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Prometheus: [, (_) => de_Prometheus(_, context), `prometheus`],
    });
};
const de_OpenMonitoringInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Prometheus: [, (_) => de_PrometheusInfo(_, context), `prometheus`],
    });
};
const de_Prometheus = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        JmxExporter: [, (_) => de_JmxExporter(_, context), `jmxExporter`],
        NodeExporter: [, (_) => de_NodeExporter(_, context), `nodeExporter`],
    });
};
const de_PrometheusInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        JmxExporter: [, (_) => de_JmxExporterInfo(_, context), `jmxExporter`],
        NodeExporter: [, (_) => de_NodeExporterInfo(_, context), `nodeExporter`],
    });
};
const de_Provisioned = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BrokerNodeGroupInfo: [, (_) => de_BrokerNodeGroupInfo(_, context), `brokerNodeGroupInfo`],
        ClientAuthentication: [, (_) => de_ClientAuthentication(_, context), `clientAuthentication`],
        CurrentBrokerSoftwareInfo: [, (_) => de_BrokerSoftwareInfo(_, context), `currentBrokerSoftwareInfo`],
        EncryptionInfo: [, (_) => de_EncryptionInfo(_, context), `encryptionInfo`],
        EnhancedMonitoring: [, smithy_client_1.expectString, `enhancedMonitoring`],
        LoggingInfo: [, (_) => de_LoggingInfo(_, context), `loggingInfo`],
        NumberOfBrokerNodes: [, smithy_client_1.expectInt32, `numberOfBrokerNodes`],
        OpenMonitoring: [, (_) => de_OpenMonitoringInfo(_, context), `openMonitoring`],
        StorageMode: [, smithy_client_1.expectString, `storageMode`],
        ZookeeperConnectString: [, smithy_client_1.expectString, `zookeeperConnectString`],
        ZookeeperConnectStringTls: [, smithy_client_1.expectString, `zookeeperConnectStringTls`],
    });
};
const de_ProvisionedThroughput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
        VolumeThroughput: [, smithy_client_1.expectInt32, `volumeThroughput`],
    });
};
const de_PublicAccess = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Type: [, smithy_client_1.expectString, `type`],
    });
};
const de_S3 = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Bucket: [, smithy_client_1.expectString, `bucket`],
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
        Prefix: [, smithy_client_1.expectString, `prefix`],
    });
};
const de_Sasl = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Iam: [, (_) => de_Iam(_, context), `iam`],
        Scram: [, (_) => de_Scram(_, context), `scram`],
    });
};
const de_Scram = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
    });
};
const de_Serverless = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ClientAuthentication: [, (_) => de_ServerlessClientAuthentication(_, context), `clientAuthentication`],
        VpcConfigs: [, (_) => de___listOfVpcConfig(_, context), `vpcConfigs`],
    });
};
const de_ServerlessClientAuthentication = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Sasl: [, (_) => de_ServerlessSasl(_, context), `sasl`],
    });
};
const de_ServerlessSasl = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Iam: [, (_) => de_Iam(_, context), `iam`],
    });
};
const de_StateInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Code: [, smithy_client_1.expectString, `code`],
        Message: [, smithy_client_1.expectString, `message`],
    });
};
const de_StorageInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        EbsStorageInfo: [, (_) => de_EBSStorageInfo(_, context), `ebsStorageInfo`],
    });
};
const de_Tls = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CertificateAuthorityArnList: [, smithy_client_1._json, `certificateAuthorityArnList`],
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
    });
};
const de_Unauthenticated = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
    });
};
const de_UnprocessedScramSecret = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ErrorCode: [, smithy_client_1.expectString, `errorCode`],
        ErrorMessage: [, smithy_client_1.expectString, `errorMessage`],
        SecretArn: [, smithy_client_1.expectString, `secretArn`],
    });
};
const de_UserIdentity = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        PrincipalId: [, smithy_client_1.expectString, `principalId`],
        Type: [, smithy_client_1.expectString, `type`],
    });
};
const de_VpcConfig = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        SecurityGroupIds: [, smithy_client_1._json, `securityGroupIds`],
        SubnetIds: [, smithy_client_1._json, `subnetIds`],
    });
};
const de_VpcConnection = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Authentication: [, smithy_client_1.expectString, `authentication`],
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        State: [, smithy_client_1.expectString, `state`],
        TargetClusterArn: [, smithy_client_1.expectString, `targetClusterArn`],
        VpcConnectionArn: [, smithy_client_1.expectString, `vpcConnectionArn`],
        VpcId: [, smithy_client_1.expectString, `vpcId`],
    });
};
const de_VpcConnectionInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        Owner: [, smithy_client_1.expectString, `owner`],
        UserIdentity: [, (_) => de_UserIdentity(_, context), `userIdentity`],
        VpcConnectionArn: [, smithy_client_1.expectString, `vpcConnectionArn`],
    });
};
const de_VpcConnectionInfoServerless = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CreationTime: [, (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(_)), `creationTime`],
        Owner: [, smithy_client_1.expectString, `owner`],
        UserIdentity: [, (_) => de_UserIdentity(_, context), `userIdentity`],
        VpcConnectionArn: [, smithy_client_1.expectString, `vpcConnectionArn`],
    });
};
const de_VpcConnectivity = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ClientAuthentication: [, (_) => de_VpcConnectivityClientAuthentication(_, context), `clientAuthentication`],
    });
};
const de_VpcConnectivityClientAuthentication = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Sasl: [, (_) => de_VpcConnectivitySasl(_, context), `sasl`],
        Tls: [, (_) => de_VpcConnectivityTls(_, context), `tls`],
    });
};
const de_VpcConnectivityIam = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
    });
};
const de_VpcConnectivitySasl = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Iam: [, (_) => de_VpcConnectivityIam(_, context), `iam`],
        Scram: [, (_) => de_VpcConnectivityScram(_, context), `scram`],
    });
};
const de_VpcConnectivityScram = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
    });
};
const de_VpcConnectivityTls = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Enabled: [, smithy_client_1.expectBoolean, `enabled`],
    });
};
const de_ZookeeperNodeInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AttachedENIId: [, smithy_client_1.expectString, `attachedENIId`],
        ClientVpcIpAddress: [, smithy_client_1.expectString, `clientVpcIpAddress`],
        Endpoints: [, smithy_client_1._json, `endpoints`],
        ZookeeperId: [, smithy_client_1.limitedParseDouble, `zookeeperId`],
        ZookeeperVersion: [, smithy_client_1.expectString, `zookeeperVersion`],
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
